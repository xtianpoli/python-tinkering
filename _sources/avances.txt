################
Concepts avancés
################

.. slide_mark_b :Concepts avancés
.. slide_insertion:* **Les fermetures (closures)**
.. slide_insertion:* **Les décorateurs de fonctions**
.. slide_insertion:* **Les générateurs**
.. slide_insertion:* **Fonctions récursives**
.. slide_insertion:* **Programmation fonctionnelle**
.. slide_mark_e

*************************
Les fermetures (closures)
*************************

.. slide_mark_b :Les fermetures (closures)

**Rappel:** En Python, les fonctions sont des objets de "premier ordre". Entre autres, un objet-fonction peut être passé en argument ou être retourné par une autre fonction :

::

   >>> def fa():
   ...     x = 123
   ...     print("je suis fa(), je renvoie fb")
   ...     def fb():
   ...             print("je suis fb() et je connais x={}".format(x))
   ...     return fb
   ... 
   >>> func_fb = fa()
   je suis fa(), je renvoie fb
   >>> func_fb()
   je suis fb() et je connais x=123
   >>> 

Dans cet exemple: 

#. la fonction *fa()* est appelée et elle retourne l'objet-fonction *fb* qui est affecté à la variable *func_fb*. A ce stade, *fb* n'a pas été exécutée, mais seulement définie (par *def*).

#. ensuite, en exécutant *func_fb()* (par l'application de *()* à la variable *func_fb*) la fonction *fb* s'exécute enfin.

.. slide_mark_e
.. slide_mark_b :Les fermetures *[2]*

De manière informelle, le terme de **fermeture** (ou *closure* en anglais) désigne une fonction (considérée en tant qu'objet) accomapgnée de son contexte de définition. Ce contexte est représenté par l'ensemble des valeurs des variables non locales à la fonction, référencées dans son code, au moment de sa définition.

Autrement dit, dans l'exemple précédent, *func_fb* (qui référence l'objet-fonction *fb*, retourné lors de l'appel de *fa()*) se "rappelle" que ``x = 123`` alors que cette information provient du contexte d'exécution de *fa()*, terminé depuis.

**NB:** On va parler de *fermeture* seulement pour les fonctions définies à l'intérieur d'autres fonctions, les seules disposant d'un contexte non local).

.. slide_mark_e
.. slide_mark_b :Les fermetures *[3]*

Pour une illustration plus complète, voici une utilisation possible des fonctions imbriquées et du principe de fermeture. 

**Scénario :** Dans une organisation, les utilisateurs peuvent avoir plusieurs profils prédéfinis, chaque profil définissant une liste de groups et une liste de protocoles autorisés.   On souhaite disposer de plusieurs fonctions permettant de créer des comptes utilisateur, une fonction pour chaque profil.


**Solution :** Nous allons définir un "générateur de profils" concrétisé par la fonction **make_profile()** qui a le rôle de "fabriquer" les fonctions créatrices de comptes souhaitées (implémentation factice qui renvoie un dictionnaire).

A chaque appel *make_profile(groups, protocols)* produira une fonction capable de créer des utilisateurs ayant un profil donné :

.. slide_mark_e
.. slide_mark_b :Les fermetures *[4]*

.. literalinclude:: includes/closure2.py
   :lines: 3-

On va utiliser cette fonction pour "fabriquer" des fonctions utilisables pour créer des comptes :

::

   >>> add_guest = make_profile(groups=['guests'],protocols=['http'])
   >>> add_staff = make_profile(groups=['staff'],protocols=['http','imap','smtp'])
   >>> add_admin = make_profile(groups=['adm', 'staff'],protocols=['http','imap',\
   ... 'smtp','ssh'])



Utilisation:

::

   >>> add_guest('alex','Alex Terrieur')
   {'org': 'Example.org', 'login': 'alex', 'protocols': ['http'], 'groups': ['guests'], 'cn': 'Alex Terrieur'}
   >>> add_staff('alain','Alain Terrieur')
   {'org': 'Example.org', 'login': 'alain', 'protocols': ['http', 'imap', 'smtp'], 'groups': ['staff'], 'cn': 'Alain Terrieur'}
   >>> add_admin('cpoli','Christian Poli')
   {'org': 'Example.org', 'login': 'cpoli', 'protocols': ['http', 'imap', 'smtp', 'ssh'], 'groups': ['adm', 'staff'], 'cn': 'Christian Poli'}


.. slide_mark_e
.. slide_mark_b :Les fermetures *[5]*

**Question légitime:** Comment les fonctions créées (*add_guest()*, *add_staff()*, *add_admin()*) ont mémorisé les valeurs de *groups*, *protocols* et *organisation* alors que ces variables ne font pas partie de leurs contextes locaux respectifs, mais du contexte d'une fonction englobante (*make_profile()*) dont l'exécution est terminée et, par conséquent, son contexte aussi?


C'est ici que la notion de **fermeture** intervient. Si on regarde de près l'objet *add_guest* par exemple:

::


   >>> dir(add_guest)
   ['__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__doc__', '__format__', '__get__', '__getattribute__', '__globals__', '__hash__', '__init__', '__module__', '__name__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', 'func_globals', 'func_name']

on observe la présence d'un attribut magique nommé **__closure__**.

Cet attribut contient:

::

   >>> add_guest.__closure__
   (<cell at 0x1156d00: str object at 0x1159090>, <cell at 0x1156e18: list object at 0x1129b90>, <cell at 0x1156de0: list object at 0x1129b48>)


et encore:

::

   >>> add_guest.__closure__[0].cell_contents
   'Example.org'
   >>> add_guest.__closure__[1].cell_contents
   ['guests']
   >>> add_guest.__closure__[2].cell_contents
   ['http']

On y reconnaît les objets référencés par les variables *organisation*, *groups* et *protocols* (on obtiendra des résultats similaires pour *add_staff* et *add_admin* ).


L'attribut *__closure__* conserve ainsi une copie partielle du contexte non local des fonctions imbriquées, faite à l'instant précis de leur définition. Cette partie de contexte conservée dans *__closure__* concerne les objets référencés dans le corps de la fonction et définis dans la (ou les) fonction(s) englobante(s).


.. slide_mark_e

Exercice
========

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/polynom.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/polynom_sol.py
      :lines: 2,10-

Une autre solution:

.. container:: tohide

   .. literalinclude:: exercices/polynom_sol2.py
      :lines: 2,10-


.. slide_mark_e



****************************
Les décorateurs de fonctions
****************************

.. slide_mark_b :Les décorateurs de fonctions

Il s'agit d'une technique simple et surtout non-intrusive permettant d'enrichir le comportement d'une fonction donnée sans modifier son code.

L'enrichissement du comportement se traduit par le rajout de nouvelles actions qui seront exécutées avant et/ou après l'exécution de la fonction elle même.

.. On va appeler "fonction décorée" la fonction dont le comportement est enrichi et "décorateur" la fonction apportant les nouveaux comportements. Une troisième fonction interviendra dans ce processus, pour faire l'assemblage des deux fonctions précédentes.

On va appeler **"fonction décorée"** la fonction dont le comportement sera enrichi et **"décoration"** la fonction apportant les nouveaux comportements.

Enfin, on appelera **"décorateur"** la fonction qui fait l'assemblage des deux fonctions précédentes.

.. Par exemple, dans une application web, certaines fonctions peuvent exiger que l'utilisateur soit authentifié. Plutôt que de rajouter cette vérification dans chaque fonction, on va préférer "décorer" les fonctions nécessitant authentification.

.. slide_mark_e
.. slide_mark_b :Les décorateurs de fonctions *[2]*
 
Les décorateurs de fonctions sont applications directes du mécanisme de **fermeture** :

.. literalinclude:: includes/simple_decorator.py


::

   >>> # exécution sans décoration:
   >>> do_something(1,2)
   fait qq chose (x=1,y=2)
   >>> do_something_else("g","r","e")
   fait qq chose d'autre (a=g,b=r,c=e)
   >>> 

.. slide_mark_e
.. slide_mark_b :Les décorateurs de fonctions *[3]*

L'application du décorateur aux deux fonctions:

::

   >>> do_something=simple_decorator(do_something)
   >>> do_something_else=simple_decorator(do_something_else)


Exécution après décoration:

::

   >>> do_something(1,2)
   action avant do_something()
   fait qq chose (x=1,y=2)
   action après do_something()
   >>> do_something_else("g","r","e")
   action avant do_something_else()
   fait qq chose d'autre (a=g,b=r,c=e)
   action après do_something_else()
   >>> 

.. slide_mark_e
.. slide_mark_b :Les décorateurs de fonctions *[4]*


Python propose une syntaxe simplifiée pour appliquer un décorateur:

.. literalinclude:: includes/simple_decorator2.py


Le décorateur présenté ici illustre bien le principe, mais il est encore imparfait. Par exemple, la *docstring* de la fonction décorée n'est pas correcte:

::

   >>> do_something.__name__
   'simple_wrapper'
   >>> do_something.__doc__
   '\n        Cette fonction constitue\n        la décoration\n        '
   >>> 


.. Les solutions à ces problèmes existent mais elles dépassent le cadre de cette introduction (pour aller plus loin voir ``functools.wraps``)

Pour y remédier, la bibliothèque standard propose un outil qui copie les informations nécessaires de la fonction initiale vers la fonction décorée. Le décorateur initial, revu et corrigé, devient:

.. literalinclude:: includes/decorator_with_functool_wraps.py


.. slide_mark_e

Exercice
========

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/lib_decorator.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/lib_decorator_sol.py
      :lines: 2,10-

.. slide_mark_e

Exercice (suite)
================

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/lib_decorator2.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/lib_decorator_sol2.py
      :lines: 2,10-

.. slide_mark_e

Exercice (suite)
================

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/lib_decorator3.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/lib_decorator_sol3.py
      :lines: 2,10-

.. slide_mark_e

***************
Les générateurs
***************

.. slide_mark_b :Les générateurs

On a déjà évoqué précédemment le fait que les objets *itérables* sont soit des *conteneurs*, autrement dit des objets qui ont vocation à contenir d'autres objets (listes, ensembles, etc.) soit des objets plus "opaques" (comme range/xrange), qui ne contiennent pas physiquement d'autres objets, mais qui les créent au fur et à mesure de la demande, de manière "paresseuse". 

Les générateurs sont des itérateurs (un itérateur peut être vu comme un itérable à usage unique!) 

Les avantages des générateurs par rapport aux conteneurs classiques:

* Consommation mémoire réduite et indépendante du nombre d'occurences
* Solution en cas d'impossibilité d'utiliser les conteneurs (quand le nombre d'occurrences n'est pas prévisible à l'avance).

.. slide_mark_e
.. slide_mark_b :Les générateurs *[2]*

Syntaxiquement, un générateur se définit avec l'instruction **def**, comme une fonction classique. 

Sur la forme, la particularité d'une fonction-générateur par rapport à une fonction classique est l'usage de l'instruction *yield*.

Sur le fond, la différence entre une fonction classique et une fonction-générateur est plus subtile :

* la fonction classique construit un résultat unique (par exemple, une liste de valeurs) qu'elle retourne d'un coup (avec l'instruction *return*)
* la fonction-générateur (où "générateur", tout court), au lieu de construire une liste d'éléments, produit et délivre les éléments un par un, à la demande, par l'instruction *yield*. Après chaque valeur délivrée, le générateur suspende son exécution tout en conservant l'état courant (les valeurs courantes des variables locales) lui permettant de reprendre l'exécution lors de la prochaine demande de nouvelle valeur.

.. slide_mark_e
.. slide_mark_b :Les générateurs *[3]*

Comme tout **itérateur**, un générateur implémente le protocole d'itération, déjà discuté précédemment.

On rappelle que, pour supporter ce protocole, un objet doit:

* implémenter la méthode *next()* (renommée *__next__()* en Python3)
* lever de l'exception *StopIteration* à la fin du processus. 
* implémenter, la méthode  *__iter__()* qui renvoie l'objet lui-même (alors qu'un itérable renvoie à chaque appel un itérateur "frais")
  
L'exécution de l'instruction *return* (explicite ou implicite) par une fonction-générateur provoque la levée de l'exception *StopIteration*. 

.. slide_mark_e
.. slide_mark_b :Les générateurs *[4]*

Pour illustration, un exemple simple de générateur, produisant les premiers *n* entiers au cube:

.. literalinclude:: includes/cube_generator.py

::

   >>> gen = gen_cube_n(3)
   >>> type(gen)
   <type 'generator'>
   >>> next(gen)
   1
   >>> next(gen)
   8
   >>> next(gen)
   27
   >>> next(gen)
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   StopIteration
   >>> for e in gen_cube_n(4):
   ...     print(e)
   ... 
   1
   8
   27
   64
   >>> 

.. slide_mark_e
.. slide_mark_b :Les générateurs *[5]*

Le même exemple en version "sans fin" :

.. literalinclude:: includes/cube_generator_endless.py


::

   >>> gen = gen_cube_endless()
   >>> next(gen)
   1
   >>> next(gen)
   8
   >>> next(gen)
   27
   >>> next(gen)
   64

.. slide_mark_e

Les générateurs "expression"
============================

.. slide_mark_b :Les générateurs "expression"

Les expressions faisant office de générateurs ont une syntaxe très proche des listes en intension, les parenthèses prenant la place des crochets englobants:

::

   >>> g= (i**3 for i in range(4))
   >>> type(g)
   <class 'generator'>
   >>> next(g)
   0
   >>> next(g)
   1
   >>> next(g)
   8
   >>> next(g)
   27
   >>> next(g)
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   StopIteration
   >>> 


.. slide_mark_e

Exercice
========

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/math_serie.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/math_serie_sol.py
      :lines: 2,10-

.. slide_mark_e


********************
Fonctions récursives
********************

.. slide_mark_b :Fonctions récursives

En Python, comme dans d'autres langages, une fonction peut s'appeler elle-même, directement  (récursion simple) ou indirectement (récursion croisée : *a()* appelle *b()* qui appelle *a()*, par exemple).


.. literalinclude:: includes/recursion.py

::

   >>> fact(4)
   24
   >>> 

.. slide_mark_e
.. slide_mark_b :Fonctions récursives *[2]*

Contrairement à d'autres langages qui accordent une place importante à la récursion (OCaml, Prolog), Python n'optimise pas la récursion terminale (tail recursion). La profondeur de la récursion est configurée par défaut à une valeur assez contraignante :

::

   >>> sys.getrecursionlimit()
   1000

   >>> fact(1001)
  File "recursion.py", line 5, in fact
    return 1 if n==0 else n*fact(n-1)
  ....
  File "recursion.py", line 5, in fact
    return 1 if n==0 else n*fact(n-1)
  RuntimeError: maximum recursion depth exceeded in comparison
  >>> 

.. slide_mark_e


.. http://neopythonic.blogspot.fr/2009/04/tail-recursion-elimination.html
.. http://stackoverflow.com/questions/3323001/maximum-recursion-depth

****************************************
Python et la programmation fonctionnelle
****************************************

.. slide_mark_b :Python et la programmation fonctionnelle

Rappel
======

La programmation fonctionnelle est une paradigme qui aborde le calcul en tant qu'évaluation des fonctions sans effet de bord, sur le modèle des fonctions mathématiques.

**Corollaire:** dans une telle approche, les changements d'état, les modifications de données sont bannis.

Les avantages revendiquées par ce paradigme sont, principalement:

* Prouvabilité formelle des programmes
* Décomposabilité/Composabilité des programmes
* Testing et mise au point facilités

.. slide_mark_e  
.. slide_mark_b :Python et la P.F. *[2]*
   
Langage multi-paradigme, Python contient des éléments de langage propices à la programmation fonctionnelle :

* les fonctions sont des objets de première classe
* il offre des mécanismes avancés pour le traitement des listes et des itérables en général:
  
  * listes en intension et générateurs-expression
  * une large palette de fonctions sur les itérateurs (module **itertools**)
  * les primitives "historiques" de la programmation fonctionnelle *map()*, *reduce()*, *filter()*
  * d'autres primitives sur les itérables: *all()*, *any()*, *min()*, *max()*   
* il permet la définition de fonctions d'ordre supérieur (fonctions qui manipulent d'autres fonctions, comme les décorateurs)

Pourtant, Python n'est pas un langage fonctionnel "pur" car :

* il n'encourage pas l'utilisation de la récursivité
* par défaut, il n'empêche pas les effets de bord (sauf dans les fonctions anonymes) ni les données modifiables

  
..  http://www.artima.com/weblogs/viewpost.jsp?thread=98196

.. slide_mark_e  
.. slide_mark_b :Python et la P.F. *[2]*

Les trois fonctions "historiques" de la programmation fonctionnelle (*map*, *filter*, *reduce*) sont présentes dans le langage, mais, dans la pratique les deux premières perdent du terrain en faveur des listes en intension et des générateurs-expression

.. sli_de_mark_e  
.. sli_de_mark_b :Outils pour la P.F. *[3]*

* **map(f, iterable1, iterable2,...)** : applique la fonction *f* sur chaque item résultat d'une itération:

  * le nombre d'arguments de la fonction doit correspondre avec le nombre d'itérables à traiter
  * les itérables seront traités parallèlement : la fonction recevra en argument, lors d'une itération *i*, le i-ème élément de chaque
  * le processus s'arrête lorsque la fin de l'itérable le plus court est atteinte

* **filter(f, iterable_in)** : applique la fonction *f* à tous les éléments de *iterable_in* et renvoie un nouvel itérable construit à partir des éléments du premier pour lesquels *f* renvoie *True*
* **reduce(f, iterable_in[,init)** : applique la fonction *f* (à deux arguments) à tous les items de *iterable_in* de manière cumulative, de gauche à droite:

  * pour [1,2,3,4] le résultat sera équivalent à  ``f(f(f(1,2),3),4)`` 
  * Si init est fourni, il sera utilisé dans le processus comme l'élément le plus à gauche. pour init=99 l'équivalent en terme de résultat sera ``f(f(f(f(99,1),2),3),4)``
  * **NB:** En version 3, la fonction *reduce* a été déplacée dans le module *functools* (cf. http://docs.python.org/3.0/whatsnew/3.0.html)

Le même document `WHATSNEW <http://docs.python.org/3.0/whatsnew/3.0.html>`_ préconise l'utilisation des listes en intension à la place de *map* et *filter* quand le résultat souhaité est une liste (car en version 3 ces deux fonctions fournissent des itérateurs en sortie)

**NB :** Les fonctions *map()* et *filter()* renvoient une liste en version 2 et un itérateur en version 3.

.. slide_mark_e


La fonction *map*
=================

.. slide_mark_b :Python et la P.F. *[4]*
.. slide_insertion:La fonction *map*

.. En principe, elle peut être utilisée pour deux raisons:

.. xxx* pour construire un nouvel objet, fourni en retour:

.. literalinclude:: includes/simple_map2.py

::

   >>> res = map(full_name,lst); list(res)
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>> # même traitement avec des listes en intension et générateurs-expression:
   >>> [full_name(e) for e in lst]
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>> res = (full_name(e) for e in lst); list(res)
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>>
   
.. slide_mark_e
.. slide_mark_b :Python et la P.F. *[5]*

Les fonctions anonymes ont le mérite de ne jamais provoquer des effets de bord, ce qui est une exigence de première importance dans la programmation fonctionnelle:

::

   >>> res = map(lambda x: x['gn']+' '+x['sn'], lst); list(res)
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>> # même traitement avec des listes en intension (pas besoin de lambda):
   >>> [e['gn']+' '+e['sn']for e in lst]
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>> # générateur-expression
   >>> res = (e['gn']+' '+e['sn']for e in lst); list(res)
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>>
            
.. x* pour l'effet de bord provoqué par l'exécution de la fonction sur le (ou les) itérables fourni(s) en argument.

.. x  .. literalinclude:: includes/simple_map.py
  
..  ::

.. x     >>> list(map(upper_sn,lst)) # la valeur de retour n'est pas intéressante
.. x     [None, None, None]
.. x     >>> lst # l'éffet de bord est la modification de la liste initiale
.. x     [{'gn': 'George', 'sn': 'WASHINGTON'}, {'gn': 'John', 'sn': 'ADAMS'}, {'gn': 'Thomas', 'sn': 'JEFFERSON'}]
.. x     >>> 

.. Cette deuxième utilisation est, généralement, une assez mauvaise idée. Une écriture avec une boucle *for* classique sera toujours plus claire dans ce cas.

.. slide_mark_e
.. slide_mark_b :Python et la P.F. *[6]*
   
   
**Remarque:** *map()* permet de travailler en parallèle sur plusieurs itérables, alors qu'avec les listes en intension on doit recourir à une astuce, l'utilisation de **zip()**:


.. literalinclude:: includes/double_map.py

::

   >>> res = map(prod, lst1, lst2); list(res)
   [7, 16, 27, 40, 55]
   >>> # avec des listes en intension:
   >>> [prod(x,y) for (x,y) in  zip(lst1, lst2)]
   [7, 16, 27, 40, 55]
   >>> # ou encore:
   >>> [x*y for (x,y) in  zip(lst1, lst2)]
   [7, 16, 27, 40, 55]
   >>> # générateur-expression
   >>> res = (prod(x,y) for (x,y) in  zip(lst1, lst2)); list(res)
   [7, 16, 27, 40, 55]
   >>>
   
.. slide_mark_e

La fonction *filter*
====================

.. slide_mark_b :Python et la P.F. *[7]*
.. slide_insertion:La fonction *filter*

::

   >>> lst = list(range(-5,8)); lst
   [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]
   >>> res = filter(lambda x: x>0, lst); list(res)
   [1, 2, 3, 4, 5, 6, 7]
   >>> # avec des listes en intension:
   >>> [x for x in lst if x>0]
   [1, 2, 3, 4, 5, 6, 7]
   >>>
   
.. slide_mark_e

La fonction *reduce*
====================

.. slide_mark_b :Python et la P.F. *[8]*
.. slide_insertion:La fonction *reduce*

::

   >>> list(range(1,5))
   [1, 2, 3, 4]
   >>> def sum(x,y):
   ...     return x+y
   ... 
   >>> reduce(sum, range(1,5))
   10
   >>> # factorielle de 5:
   >>> from functools import reduce
   >>> reduce(lambda x,y:x*y, range(1,6)) 
   120
   >>>    

.. slide_mark_e

Le module *itertools*
=====================

.. slide_mark_b :Python et la P.F. *[8]*
.. slide_insertion:Le module *itertools*


`itertools <https://docs.python.org/3/library/itertools.html>`_ fournit des itérables très utiles, en programmation fonctionnelle ou impérative, illustré ici sur un exemple. Soit le générateur suivant implémentant une série:

.. literalinclude:: includes/exo_itertools.py

On souhaite implémenter un itérable "paresseux" qui fournit à chaque itération, le terme courant de la série et la somme des éléments déjà générés                    

::

   >>> from itertools import accumulate, tee
   >>> crt, acc = tee(series())
   >>> crt_acc = zip(crt, accumulate(acc))
   >>> for res, _ in zip(crt_acc, range(5)):
   ...     print(res)
   ... 
   (-5, -5)
   (4, -1)
   (15, 14)
   (28, 42)
   (43, 85)
   >>> 


.. slide_mark_e
