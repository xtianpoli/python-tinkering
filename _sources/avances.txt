################
Concepts avancés
################

.. slide_mark_b :Concepts avancés
.. slide_insertion:* **Les fermetures (closures)**
.. slide_insertion:* **Les décorateurs de fonctions**
.. slide_insertion:* **Les générateurs**
.. slide_insertion:* **Fonctions récursives**
.. slide_insertion:* **Programmation fonctionnelle**
.. slide_mark_e

*************************
Les fermetures (closures)
*************************

.. slide_mark_b :Les fermetures (closures)

**Rappel:** En Python, les fonctions sont des objets de "première classe". Entre autres, un objet-fonction peut être passé en argument ou être retourné par une autre fonction :

::

   >>> def fa():
   ...     x = 123
   ...     print("je suis fa(), je renvoie fb")
   ...     def fb():
   ...             print("je suis fb() et je connais x={}".format(x))
   ...     return fb
   ... 
   >>> func_fb = fa()
   je suis fa(), je renvoie fb
   >>> func_fb()
   je suis fb() et je connais x=123
   >>> 

Dans cet exemple: 

#. la fonction *fa()* est appelée et elle retourne l'objet-fonction *fb* qui est affecté à la variable *func_fb*. A ce stade, *fb* n'a pas été exécutée, mais seulement définie (par *def*).

#. ensuite, en exécutant *func_fb()* (par l'application de *()* à la variable *func_fb*) la fonction *fb* s'exécute enfin.

.. slide_mark_e
.. slide_mark_b :Les fermetures {tcnt_}

De manière informelle, le terme de **fermeture** (ou *closure* en anglais) désigne une fonction (considérée en tant qu'objet) accompagnée de son contexte de définition. Ce contexte est représenté par l'ensemble des valeurs des variables non locales à la fonction, référencées dans son code, au moment de sa définition.

Autrement dit, dans l'exemple précédent, *func_fb* (qui référence l'objet-fonction *fb*, retourné lors de l'appel de *fa()*) se "rappelle" que ``x = 123`` alors que cette information provient du contexte d'exécution de *fa()*, terminé depuis.

**NB:** On va parler de *fermeture* seulement pour les fonctions définies à l'intérieur d'autres fonctions, les seules disposant d'un contexte non local).

.. slide_mark_e
.. slide_mark_b :Les fermetures {tcnt_}

Pour une illustration plus complète, voici une utilisation possible des fonctions imbriquées et du principe de fermeture. 

**Scénario :** Dans une organisation, les utilisateurs des moyens informatiques peuvent avoir plusieurs profils prédéfinis, chaque profil définissant une liste de groups et une liste de protocoles autorisés.   On souhaite disposer de plusieurs fonctions permettant de créer des comptes utilisateur, une fonction pour chaque profil.


**Solution :** Nous allons définir un "générateur de profils" concrétisé par la fonction **make_profile()** qui a le rôle de "fabriquer" les fonctions créatrices de comptes souhaitées (implémentation factice qui renvoie un dictionnaire).

A chaque appel *make_profile(groups, protocols)* produira une fonction capable de créer des utilisateurs ayant un profil donné :

.. slide_mark_e
.. slide_mark_b :Les fermetures {tcnt_}

.. literalinclude:: includes/closure2.py
   :lines: 3-

On va utiliser cette fonction pour "fabriquer" des fonctions utilisables pour créer des comptes :

::

   >>> add_guest = make_profile(groups=['guests'],protocols=['http'])
   >>> add_staff = make_profile(groups=['staff'],protocols=['http','imap','smtp'])
   >>> add_admin = make_profile(groups=['adm', 'staff'],protocols=['http','imap',\
   ... 'smtp','ssh'])



Utilisation:

::

   >>> add_guest('alex','Alex Terrieur')
   {'org': 'Example.org', 'login': 'alex', 'protocols': ['http'], 'groups': ['guests'], 'cn': 'Alex Terrieur'}
   >>> add_staff('alain','Alain Terrieur')
   {'org': 'Example.org', 'login': 'alain', 'protocols': ['http', 'imap', 'smtp'], 'groups': ['staff'], 'cn': 'Alain Terrieur'}
   >>> add_admin('cpoli','Christian Poli')
   {'org': 'Example.org', 'login': 'cpoli', 'protocols': ['http', 'imap', 'smtp', 'ssh'], 'groups': ['adm', 'staff'], 'cn': 'Christian Poli'}


.. slide_mark_e
.. slide_mark_b :Les fermetures {tcnt_}

**Question légitime:** Comment les fonctions créées (*add_guest()*, *add_staff()*, *add_admin()*) ont mémorisé les valeurs de *groups*, *protocols* et *organisation* alors que ces variables ne font pas partie de leurs contextes locaux respectifs, mais du contexte d'une fonction englobante (*make_profile()*) dont l'exécution est terminée et, par conséquent, son contexte aussi?


C'est ici que la notion de **fermeture** intervient. Si on regarde de près l'objet *add_guest* par exemple:

::


   >>> dir(add_guest)
   ['__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__doc__', '__format__', '__get__', '__getattribute__', '__globals__', '__hash__', '__init__', '__module__', '__name__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', 'func_globals', 'func_name']

on observe la présence d'un attribut magique nommé **__closure__**.

Cet attribut contient:

::

   >>> add_guest.__closure__
   (<cell at 0x1156d00: str object at 0x1159090>, <cell at 0x1156e18: list object at 0x1129b90>, <cell at 0x1156de0: list object at 0x1129b48>)


et encore:

::

   >>> add_guest.__closure__[0].cell_contents
   'Example.org'
   >>> add_guest.__closure__[1].cell_contents
   ['guests']
   >>> add_guest.__closure__[2].cell_contents
   ['http']

On y reconnaît les objets référencés par les variables *organisation*, *groups* et *protocols* (on obtiendra des résultats similaires pour *add_staff* et *add_admin* ).


L'attribut *__closure__* conserve ainsi une copie partielle du contexte non local des fonctions imbriquées, faite à l'instant précis de leur définition. Cette partie de contexte conservée dans *__closure__* concerne les objets référencés dans le corps de la fonction et définis dans la (ou les) fonction(s) englobante(s).


.. slide_mark_e

Exercice
========

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/polynom.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/polynom_sol.py
      :lines: 2,10-

Une autre solution:

.. container:: tohide

   .. literalinclude:: exercices/polynom_sol2.py
      :lines: 2,10-


.. slide_mark_e



****************************
Les décorateurs de fonctions
****************************

.. slide_mark_b :Les décorateurs de fonctions

Il s'agit d'une technique simple et surtout non-intrusive permettant d'enrichir le comportement d'une fonction donnée sans modifier son code.

L'enrichissement du comportement se traduit par le rajout de nouvelles actions qui seront exécutées avant et/ou après l'exécution de la fonction elle même.

.. On va appeler "fonction décorée" la fonction dont le comportement est enrichi et "décorateur" la fonction apportant les nouveaux comportements. Une troisième fonction interviendra dans ce processus, pour faire l'assemblage des deux fonctions précédentes.

On va appeler **"fonction décorée"** la fonction dont le comportement sera enrichi et **"décoration"** la fonction apportant les nouveaux comportements.

Enfin, on appelera **"décorateur"** la fonction qui fait l'assemblage des deux fonctions précédentes.

.. Par exemple, dans une application web, certaines fonctions peuvent exiger que l'utilisateur soit authentifié. Plutôt que de rajouter cette vérification dans chaque fonction, on va préférer "décorer" les fonctions nécessitant authentification.

.. slide_mark_e
.. slide_mark_b :Les décorateurs de fonctions {tcnt_}
 
Les décorateurs de fonctions sont applications directes du mécanisme de **fermeture** :

.. literalinclude:: includes/simple_decorator.py


::

   >>> # exécution sans décoration:
   >>> do_something(1,2)
   fait qq chose (x=1,y=2)
   >>> do_something_else("g","r","e")
   fait qq chose d'autre (a=g,b=r,c=e)
   >>> 

.. slide_mark_e
.. slide_mark_b :Les décorateurs de fonctions {tcnt_}

L'application du décorateur aux deux fonctions:

::

   >>> do_something=simple_decorator(do_something)
   >>> do_something_else=simple_decorator(do_something_else)


Exécution après décoration:

::

   >>> do_something(1,2)
   action avant do_something()
   fait qq chose (x=1,y=2)
   action après do_something()
   >>> do_something_else("g","r","e")
   action avant do_something_else()
   fait qq chose d'autre (a=g,b=r,c=e)
   action après do_something_else()
   >>> 

.. slide_mark_e
.. slide_mark_b :Les décorateurs de fonctions {tcnt_}


Python propose une syntaxe simplifiée pour appliquer un décorateur:

.. literalinclude:: includes/simple_decorator2.py


Le décorateur présenté ici illustre bien le principe, mais il est encore imparfait. Par exemple, la *docstring* de la fonction décorée n'est pas correcte:

::

   >>> do_something.__name__
   'simple_wrapper'
   >>> do_something.__doc__
   '\n        Cette fonction constitue\n        la décoration\n        '
   >>> 


.. Les solutions à ces problèmes existent mais elles dépassent le cadre de cette introduction (pour aller plus loin voir ``functools.wraps``)

Pour y remédier, la bibliothèque standard propose un outil qui copie les informations nécessaires de la fonction initiale vers la fonction décorée. Le décorateur initial, revu et corrigé, devient:

.. literalinclude:: includes/decorator_with_functool_wraps.py

Quelques exemples : https://wiki.python.org/moin/PythonDecoratorLibrary            
                    

.. slide_mark_e

Exercice
========

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/lib_decorator.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/lib_decorator_sol.py
      :lines: 2,10-

.. slide_mark_e

Exercice (suite)
================

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/lib_decorator2.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/lib_decorator_sol2.py
      :lines: 2,10-

.. slide_mark_e

Exercice (suite)
================

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/lib_decorator3.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/lib_decorator_sol3.py
      :lines: 2,10-

.. slide_mark_e

***************
Les générateurs
***************

.. slide_mark_b :Les générateurs

On a déjà évoqué précédemment le fait que les objets *itérables* sont soit des *conteneurs*, autrement dit des objets qui ont vocation à contenir d'autres objets (listes, ensembles, etc.) soit des objets plus "opaques" (comme range/xrange), qui ne contiennent pas physiquement d'autres objets, mais qui les créent au fur et à mesure de la demande, de manière "paresseuse". 

Les générateurs sont des itérateurs (un itérateur peut être vu comme un itérable à usage unique!) 

Les avantages des générateurs par rapport aux conteneurs classiques:

* Consommation mémoire réduite et indépendante du nombre d'occurences
* Solution en cas d'impossibilité d'utiliser les conteneurs (quand le nombre d'occurrences n'est pas prévisible à l'avance).

.. slide_mark_e
.. slide_mark_b :Les générateurs {tcnt_}

Syntaxiquement, un générateur se définit avec l'instruction **def**, comme une fonction classique. 

Sur la forme, la particularité d'une fonction-générateur par rapport à une fonction classique est l'usage de l'instruction *yield*.

Sur le fond, la différence entre une fonction classique et une fonction-générateur est plus subtile :

* la fonction classique construit un résultat unique (par exemple, une liste de valeurs) qu'elle retourne d'un coup (avec l'instruction *return*)
* la fonction-générateur (où "générateur", tout court), au lieu de construire une liste d'éléments, produit et délivre les éléments un par un, à la demande, par l'instruction *yield*. Après chaque valeur délivrée, le générateur suspende son exécution tout en conservant l'état courant (les valeurs courantes des variables locales) lui permettant de reprendre l'exécution lors de la prochaine demande de nouvelle valeur.

.. slide_mark_e
.. slide_mark_b :Les générateurs {tcnt_}

Comme tout **itérateur**, un générateur implémente le protocole d'itération, déjà discuté précédemment.

On rappelle que, pour supporter ce protocole, un objet doit:

* implémenter la méthode *next()* (renommée *__next__()* en Python3)
* lever de l'exception *StopIteration* à la fin du processus. 
* implémenter, la méthode  *__iter__()* qui renvoie l'objet lui-même (alors qu'un itérable renvoie à chaque appel un itérateur "frais")
  
L'exécution de l'instruction *return* (explicite ou implicite) par une fonction-générateur provoque la levée de l'exception *StopIteration*. 

.. slide_mark_e
.. slide_mark_b :Les générateurs {tcnt_}

Pour illustration, un exemple simple de générateur, produisant les premiers *n* entiers au cube:

.. literalinclude:: includes/cube_generator.py

::

   >>> gen = gen_cube_n(3)
   >>> type(gen)
   <type 'generator'>
   >>> next(gen)
   1
   >>> next(gen)
   8
   >>> next(gen)
   27
   >>> next(gen)
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   StopIteration
   >>> for e in gen_cube_n(4):
   ...     print(e)
   ... 
   1
   8
   27
   64
   >>> 

.. slide_mark_e
.. slide_mark_b :Les générateurs {tcnt_}

Le même exemple en version "sans fin" :

.. literalinclude:: includes/cube_generator_endless.py


::

   >>> gen = gen_cube_endless()
   >>> next(gen)
   1
   >>> next(gen)
   8
   >>> next(gen)
   27
   >>> next(gen)
   64

.. slide_mark_e

Les générateurs "expression"
============================

.. slide_mark_b :Les générateurs "expression"

Les expressions faisant office de générateurs ont une syntaxe très proche des listes en intension, les parenthèses prenant la place des crochets englobants:

::

   >>> g= (i**3 for i in range(4))
   >>> type(g)
   <class 'generator'>
   >>> next(g)
   0
   >>> next(g)
   1
   >>> next(g)
   8
   >>> next(g)
   27
   >>> next(g)
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   StopIteration
   >>> 


.. slide_mark_e


   
   
Les générateurs à l'oeuvre ...
==============================

.. slide_mark_b :Les générateurs à l'oeuvre ...

Cette fonction appartenant au module **os** de la **bibliothèque standard** permet de parcourir une arborescence de fichiers ayant pour racine le répertoire *top* :
   
::

    os.walk(top, topdown=True, onerror=None, followlinks=False)

Elle retourne un générateur qui fournit à chaque itération un triplet de valeurs contenant:

* le nom du répertoire courant
* la liste des sous-répertoires directs
* la liste des fichiers membres

Les options:

* topdown : 
  
  * True : l'itération se fait à partir de la racine (valeur par défaut)
  * False: l'itération se fait à partir des "feuilles"

* onerror : None (par défaut) ou une fonction utilisateur qui sera appelée en cas d'erreur.

* followlinks : suivi des liens symboliques (si *True*). Peut provoquer une récursion infinie en cas de liens cycliques

.. slide_mark_e
.. slide_mark_b :Les générateurs à l'oeuvre {tcnt_}

Exemples:

* top-down :

  ::

     >>> import os
     >>> g=os.walk("/usr/local/lib/python2.7/dist-packages/")
     >>> type(g)
     <type 'generator'>
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/', ['django_http_proxy-0.3.2-py2.7.egg', 'django_guardian-1.0.4-py2.7.egg', 'Whoosh-2.4.1-py2.7.egg', 'vnc2flv', 'codenode-0.02-py2.7.egg', 'django', 'easy_thumbnails-1.0.3-py2.7.egg', 'Twisted-12.3.0-py2.7-linux-x86_64.egg', 'django_userena-1.1.2-py2.7.egg', 'django_compress-1.0.1-py2.7.egg', 'django_passwords-0.2.0-py2.7.egg'], ['vnc2flv-20100207.egg-info', 'flvscreen.so', 'Django-1.5.4.egg-info', 'easy-install.pth'])
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/django_http_proxy-0.3.2-py2.7.egg', ['EGG-INFO', 'httpproxy'], [])
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/django_http_proxy-0.3.2-py2.7.egg/EGG-INFO', [], ['zip-safe', 'SOURCES.txt', 'PKG-INFO', 'dependency_links.txt', 'top_level.txt'])
     >>> # etc...

* bottom-up :

  ::

     >>> g=os.walk("/usr/local/lib/python2.7/dist-packages/",topdown=False)
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/django_http_proxy-0.3.2-py2.7.egg/EGG-INFO', [], ['zip-safe', 'SOURCES.txt', 'PKG-INFO', 'dependency_links.txt', 'top_level.txt'])
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/django_http_proxy-0.3.2-py2.7.egg/httpproxy', [], ['views.pyc', 'settings.pyc', 'recorder.py', '__init__.py', 'exceptions.pyc', 'views.py', 'settings.py', 'decorators.py', 'models.pyc', 'recorder.pyc', 'models.py', 'admin.py', '__init__.pyc', 'admin.pyc', 'decorators.pyc', 'exceptions.py'])
     >>> 


.. slide_mark_e
   


Exercice
========

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/math_serie.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/math_serie_sol.py
      :lines: 2,10-

.. slide_mark_e


********************
Fonctions récursives
********************

.. slide_mark_b :Fonctions récursives

En Python, comme dans d'autres langages, une fonction peut s'appeler elle-même, directement  (récursion simple) ou indirectement (récursion croisée : *a()* appelle *b()* qui appelle *a()*, par exemple).


.. literalinclude:: includes/recursion.py

::

   >>> fact(4)
   24
   >>> 

.. slide_mark_e
.. slide_mark_b :Fonctions récursives {tcnt_}

Contrairement à d'autres langages qui accordent une place importante à la récursion (OCaml, Prolog), Python n'optimise pas la récursion terminale (tail recursion). La profondeur de la récursion est configurée par défaut à une valeur assez contraignante :

::

   >>> sys.getrecursionlimit()
   1000

   >>> fact(1001)
  File "recursion.py", line 5, in fact
    return 1 if n==0 else n*fact(n-1)
  ....
  File "recursion.py", line 5, in fact
    return 1 if n==0 else n*fact(n-1)
  RuntimeError: maximum recursion depth exceeded in comparison
  >>> 

.. slide_mark_e


.. http://neopythonic.blogspot.fr/2009/04/tail-recursion-elimination.html
.. http://stackoverflow.com/questions/3323001/maximum-recursion-depth
