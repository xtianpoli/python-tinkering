#############
Les fonctions
#############

.. slide_mark_b :Les fonctions

Au cours des chapitres précédents on a été amené à appeler des fonctions prédéfinies (built-in).

Dans ce chapitre on va expliquer comment définir ses propres fonctions et on va détailler l'ensemble des mécanismes intervenant dans la définition et dans l'appel d'une fonction. On va également revenir sur le concept de variable pour introduire la notion de *portée*.

.. slide_mark_e

******************
Une vue d'ensemble
******************

Une fonction très simple
========================

.. slide_mark_b :Une fonction très simple

.. literalinclude:: includes/fonction_simple.py

Premières remarques:

* Une fonction est définie avec *def*
* *def* est une **instruction** (et non pas une déclaration, directive etc.) qui, entre autres, opère une **affectation** de variable.
* Le nom introduit avec *def*, le mot *say_hi*, est une *variable* comme une autre, référençant un objet de type *function*.

::

   >>> def say_hi(name):
   ...     print("Hi {}!".format(name))
   ... 
   >>> say_hi('Mom')
   Hi Mom!
   >>> say_hi # est une variable
   <function say_hi at 0x7f23515985f0>


.. slide_mark_e

L'instruction **return**
========================

.. slide_mark_b :L'instruction **return**

En Python, comme en C/C++ et Java, une fonction retourne **toujours** une valeur. En Python, en absence de l'instruction *return* ou en cas d'appel de l'instruction *return* sans argument, la valeur de retour est **None**.

::

   >>> res # au départ, n'existe pas
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   NameError: name 'res' is not defined
   >>> res = say_hi('Mom')
   Hi Mom!
   >>> res # existe bien maintenant (plus d'erreur)!
   >>> 
   >>> res is None
   True

.. slide_mark_e
.. slide_mark_b :L'instruction **return** {tcnt_}

L'instruction *return* peut être suivie d'une expression qui sera évaluée pour calculer la valeur de retour:

.. literalinclude:: includes/fonction_return.py

::

   >>> cube(2)
   8
   >>> 

.. slide_mark_e
.. slide_mark_b :L'instruction **return** {tcnt_}

**Astuce:** Si la valeur de retour est une séquence (tuple, liste etc.), le résultat retourné peut être récupéré directement dans plusieurs variables (par **unpacking**) :

::

   >>> def f():
   ...     # ...
   ...     # ...
   ...     return 5, "abc", [5,6]
   ... 
   >>> x, y, z = f()
   >>> x
   5
   >>> y
   'abc'
   >>> z
   [5, 6]
   >>> 

.. slide_mark_e

Exercice
--------

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/complexnum.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/complexnum_sol.py
      :lines: 2,10-

.. slide_mark_e
              
Les fonctions imbriquées
========================

.. slide_mark_b :Les fonctions imbriquées

En Python les définitions des fonctions peuvent s'imbriquer à volonté:

::

   >>> def cube(x):
   ...     def square(t):
   ...         return t**2
   ...     return x*square(x)
   ... 
   >>> cube(2)
   8
   >>> 

Dans les chapitres suivants on va rencontrer des utilisations plus pertinentes de cette propriété ...

.. slide_mark_e

***********************
La portée des variables
***********************

.. slide_mark_b :La portée des variables

On a vu précédemment que définir une variable revient à associer une référence d'objet à un nom. Une variable peut donc être définie à l'intérieur d'une fonction comme en dehors de toute fonction. Selon l'endroit de leur définition, la "visibilité" des variables, appelée couramment **portée** (*scope* en anglais) n'est pas la même.

**Python 2.x** implémente 2 niveaux de portée:

* *local*, qui est celui de la fonction, i.e. du bloc *def*. Il est accessible via la primitive *locals()*

* *global*, celui du module, i.e. du fichier, accessible via la primitive *globals()*. 

.. slide_mark_e
.. slide_mark_b :La portée des variables {tcnt_}

::

   >>> def f(arg):
   ...     x = arg
   ...     print(locals())
   ... 
   >>> f(5)
   {'x': 5, 'arg': 5}
   >>> globals()
   {'__builtins__': <module '__builtin__' (built-in)>, '__name__': '__main__', 'f': <function f at 0x10815f0>, '__doc__': None, '__package__': None}
   >>> 

**NB :** Des noms identiques, définis dans des modules distincts, peuvent coexister dans un même contexte, sans conflit, car ils seront préfixés par le nom de leur module de définition, après importation.

.. slide_mark_e
.. slide_mark_b :La portée des variables {tcnt_}

.. note:: En *Python*, contrairement à *C++* et *Java*, la portée locale est relative **exclusivement** au contexte de la fonction. Il n'y a pas de portée locale liée à un autre type de bloc d'instructions (comme c'est le cas pour  les boucles *while* ou *for* en *Java* et *C++*), sauf pour deux cas très particuliers :

   * la variable de liste en intension (seulement depuis Python 3)
   * la variable du bloc *except* (introduite par *as*) 

   Autrement dit, une affectation de variable faite à l'intérieur d'une boucle *while* ou *for* dans une fonction sera visible dans le corps de la fonction même après la sortie de la boucle.
   L'exemple suivant illustre ce comportement avec une boucle *for* dans une fonction:

.. slide_mark_e
.. slide_mark_b :La portée des variables {tcnt_}

.. literalinclude:: includes/fun_scope.py

::

   >>> x = 5
   >>> f()
   values in the context of f(): x=3, y=2, i=2
   >>> 
   >>> x
   5



On constate que les variables *x*, *y* et *i* conservent les modifications intervenues à l'intérieur de la boucle *for* après la sortie du bloc. 

En plus, *y* et *i* apparaissent pour la première fois dans le *for*, et pourtant elles sont présentes dans le contexte de la fonction, après la sortie de la boucle. 

.. slide_mark_e

Que se passe-t-il en cas de conflit?
====================================

.. slide_mark_b :Que se passe-t-il en cas de conflit?

Des conflits de nom de variable peuvent apparaître entre le niveau local et global. Plusieurs situations peuvent se présenter:

* **référencement:** la variable globale est accédée en lecture à l'intérieur de la fonction:

  ::

     >>> x=1
     >>> def f():
     ...     print(x)
     ... 
     >>> f()
     1
     >>> 

.. slide_mark_e
.. slide_mark_b :Que se passe-t-il en cas de conflit? {tcnt_}
     

* **affectation:** la variable globale est "cachée" (silencieusement) par son homonyme locale:

  ::

     >>> x=1
     >>> def f():
     ...     x = 2
     ...     print("x={}".format(x))
     ... 
     >>> f()
     x=2
     >>> x
     1
     >>> 

.. slide_mark_e
.. slide_mark_b :Que se passe-t-il en cas de conflit? {tcnt_}

* **référencement suivi d'affectation** situation plus contrariante pour l'interpréteur (mais réaction logique):

  ::

     >>> x=1
     >>> def f():
     ...     print("x={}".format(x))
     ...     x = 2
     ... 
     >>> f()
     Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
     File "<stdin>", line 2, in f
     UnboundLocalError: local variable 'x' referenced before assignment
     >>> 

.. slide_mark_e

L'instruction **global**
========================

.. slide_mark_b :L'instruction **global**

La sémantique de cette instruction rappelle les déclarations de variables des autres langages. 

Appelée à l'intérieur d'une fonction, elle prends la forme ``global var1[,var2][,...]`` et elle indique à l'interpréteur que les variables var1, var2, ... font partie du contexte global:

::

   >>> x=1
   >>> def f():
   ...     global x
   ...     x=2
   ... 
   >>> x
   1
   >>> f()
   >>> x
   2
   >>> 

**NB:** En complément de l'instruction *global*, Python 3 introduit l'instruction *nonlocal* qui sera expliquée par la suite.

.. slide_mark_e

La résolution des noms
======================

.. slide_mark_b :La résolution des noms

Pour toute variable qui n'est pas **global** ou **nonlocal**, les règles suivantes s'appliquent:

* L'**affectation** de variable à l'intérieur d'une fonction **F** se fait dans le contexte local de la fonction
* Toute **référence** à une variable à l'intérieur de **F** donnera lieu à une recherche dans plusieurs endroits, dans l'ordre suivant (la recherche s'arrête au premier succès):

  #. Le contexte local de **F**
  #. Si **F** est définie à l'intérieur d'une autre fonction **G** on va chercher la variable dans le contexte local de **G**. En cas d'échec la recherche continuera en remontant les contextes des fonctions englobantes, s'il y en a.
  #. Le contexte global du module
  #. Le contexte des noms prédéfinis (built-ins)

**NB:** 

* Si la variable est **global**, la recherche commencera à l'étape **3**
* Les paramètres d'une fonction font partie du contexte local de celle ci.

.. slide_mark_e

**Illustration:**

.. slide_mark_b :La résolution de noms {tcnt_}
   
.. literalinclude:: includes/resolution.py

.. slide_mark_e
.. slide_mark_b :La résolution de noms {tcnt_}
                    
::

   >>> fun()
   x=1
   y=22
   z=333
   True=True
   >>> 


On voit que :

* **z** provient du contexte local de fun2()
* **y** provient du contexte local de fun() (qui contient fun2())
* **x** provient du contexte global
* **True** est une variable du contexte built-in

.. slide_mark_e
.. slide_mark_b :La résolution de noms {tcnt_}

**Problème:**

Supposons qu'on veut modifier l'exemple précédent pour que la fonction **fun2()** modifie **y** dans le contexte de **fun()** mais pas dans le contexte global (car pour le niveau global il suffirait de déclarer **global y** à l'intérieur de **fun2()**)

**Réponse:**

* **Python 2.x:** il n'y a pas de solution
* **Python 3.x:** il suffit de déclarer **nonlocal y**:

.. slide_mark_e

**Illustration** avec l'exemple précédent modifié (on a tracé **y** à tous les niveaux et éliminé les variables **x** et **z**):

.. slide_mark_b :La résolution de noms {tcnt_}
   
.. literalinclude:: includes/resolution_nonlocal.py

::

   $ python3 resolution_nonlocal.py 
   fun2(): y=22 [avant affectation]
   fun2(): y=99 [apres affectation]
   fun(): y=99
   global: y=2

.. slide_mark_e

L'instruction **nonlocal**
==========================

.. slide_mark_b :L'instruction **nonlocal**

Cette instruction à été introduite avec la version 3 pour répondre au besoin illustré précédemment. 

La résolution des noms, aussi bien pour l'affectation que pour le référencement, se fait suivant l'étape 2 (seulement) du processus décrit précédemment pour le référencement des variables locales. 

Ainsi, si la variable n'est pas trouvée dans un des blocs **def** qui englobent la fonction contenant la déclaration **nonlocal**, une erreur de syntaxe se produit (même si la variable existe dans le contexte global!)

.. slide_mark_e

Exercice
--------

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/varscope.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/varscope_sol.py
      :lines: 2,10-


.. slide_mark_e
   
************************
Signatures des fonctions
************************

.. slide_mark_b :Signatures des fonctions

La signature d'une fonction est composée du nom de la fonction suivi, entre parenthèses, par la liste de ses paramètres (ensemble qui peut être vide). Elle représente la première partie de l'instruction **def** et est suivie par **":"**.

La forme générale d'une signature est:

*def* **nom_fonction(p1, p2, ...)** *:*

les paramètres *p1*, *p2*,... pouvant prendre plusieurs formes.


.. admonition:: **Vocabulaire**
   :class: note

   On va appeler :

   * **"paramètres"** les entités appelées  *p1*, *p2*, ..., faisant partie de la **signature** de la fonction.
   * **"arguments"** les valeurs concrètes (références, en fait) passées à la fonction lors des **appels** .

.. slide_mark_e
.. slide_mark_b :Signatures des fonctions {tcnt_}
   
On va distinguer :

* **paramètres simples** ou (mono-valués) : les paramètres recevant un seul argument (maximum) lors des appels de la fonction. Ils peuvent être :
     
  * à argument **obligatoire** : ils doivent recevoir un (et un seul) argument à l'appel de la fonction
  * à argument **facultatif** : ayant une valeur par défaut qui s'applique en absence d'un argument à l'appel
* **paramètres variadiques** (multi-valués) les paramètres pouvant recevoir un nombre indéterminé (0..N) d'arguments lors des appels de la fonction. Leur rôle est assez similaire à celui du paramètre **"..."** présent dans d'autres langages (**C**, **R**, ...). Ils peuvent être, à leur tour:

  * à arguments **positionnels** ou **non-keyword** qu'on va appeler par la suite **"paramètre étoile"**
  * à arguments **nommés** ou **keyword** qu'on va appeler ici **"paramètre double-étoile"**
       
 **NB :** On a utilisé des noms de la forme *arg_x*, *args*, *kwargs* pour nommer des paramètres afin de mieux identifier leur rôle.

On va voir que, dans le cas le plus général, **il n'y a pas de bijection paramètre<=>argument**.


.. Dans une signature de fonction, trois catégories de paramètres peuvent être présentes, toutes optionnelles :
.. docs.python.org/dev/reference/compound_stmts.html#function-definitions
.. docs.python.org/dev/tutorial/controlflow.html#more-on-defining-functions

.. slide_mark_e
.. slide_mark_b :Signatures des fonctions {tcnt_}

   
La double dichotomie précédente donne quatre catégories de paramètres :   
   
.. literalinclude:: includes/param_types.txt


* paramètres **simples** à argument **obligatoire** : syntaxiquement, ce sont des variables regroupés à gauche dans la signature ( **arg_1**,..., **arg_i-1**). A l'appel de la fonction, chaque variable de ce groupe (**(O)** sur le schéma) recevra obligatoirement un argument (et un seul).
* paramètres **simples** à argument **facultatif** (syntaxe : *variable=valeur_par_defaut* ) représentés par **arg_1**,..., **arg_i-1**, groupe **(F)** sur le schéma. A l'appel de la fonction, les valeurs par défaut s'appliquent, si nécessaire, à la place des arguments manquants correspondants. Cette notation (*nom=valeur*) est connue sous le nom de "syntaxe **keyword**" en jargon Python. Dans la suite, on va l'appeler parfois aussi "syntaxe **clé-valeur**".
  **NB :** Tous les paramètres suivant un paramètre à valeur par défaut doivent avoir aussi une valeur par défaut. 
* paramètre **variadique** à valeurs **positionnelles** (syntaxe **\*nom** ), groupe **(P)** sur le schéma reçoit, à l'appel, un nombre arbitraire (0..\*) d'arguments sous la forme d'un tuple (noté **\*args** dans la suite), l'ordre des arguments à l'appel étant respectée dans le tuple. 
* paramètre **variadique** à valeurs **nommées** (syntaxe **\*\*nom** )  reçoit, à l'appel, un nombre arbitraire (0..\*) d'arguments "clé-valeur" sous la forme d'un dictionnaire (noté **\*\*kwargs** dans la suite)

.. slide_mark_e
.. slide_mark_b :Signatures des fonctions {tcnt_}

Si présents, les différents paramètres évoqués apparaissent dans la signature dans cet ordre:


::

   def func(arg_1, ..., arg_i-1, arg_i, ..., arg_n, *args, **kwargs):
      ...

**Remarque :** La seule manière d'"alimenter" le  paramètre **\*args** lors de l'appel de **func()** (par exemple avec **m** > 0 arguments) est de fournir lors de l'appel **n + m** arguments positionnels. Il s'agit donc de fournir des arguments explicites pour **tous** les paramètres simples, y compris pour ceux qui ont une valeur par défaut, même si la valeur par défaut est bien celle souhaitée.

.. slide_mark_e
.. slide_mark_b :Signatures des fonctions {tcnt_}

Dans cette situation, la correspondance entre les paramètres de la signature et les arguments à l'appel se présente ainsi :

.. literalinclude:: includes/param_args.txt

.. Tous les types de paramètres étant facultatifs, tous les cas de figure sont autorisées si l'ordre des trois types (quand ils sont présents) est respectée.

.. slide_mark_e


Les paramètres simples
======================

.. slide_mark_b :Les paramètres simples

Représentés précédemment par *arg_1,...,arg_n*. On rappelle qu'un paramètre simple peut être:

* obligatoire  (syntaxe : *une variable*) : à l'appel, il recevra obligatoirement un argument (et un seul).
* facultatif (syntaxe : *variable=valeur_par_défaut*) : à l'appel, l'argument correspondant au paramètre peut manquer, et dans ce cas la valeur par défaut sera utilisée.


On va rappeler également  qu'un paramètre facultatif ne peut pas être suivi, dans la signature, par un paramètre obligatoire.

.. slide_mark_e
.. slide_mark_b :Les paramètres simples {tcnt_}

**Exemple**

Une fonction de division avec une option de division tronquée:


.. literalinclude:: includes/div.py

::

   >>> div(5,12)
   0.4166666666666667
   >>> div(5,12,False)
   0.4166666666666667
   >>> div(5,12,True)
   0
   >>>
   
.. slide_mark_e
.. slide_mark_b :Les paramètres simples {tcnt_}

.. admonition:: Attention
   :class: warning

    Les valeurs par défaut ne sont pas évaluées à chaque appel de la fonction, mais une seule fois, à l'appel de l'instruction **def** (qui se produit en règle générale une seule fois, au chargement d'un module, pour les fonctions non-imbriquées)

::

   >>> k = 7
   >>> def f(x=k+3):
   ...     print(x)
   ... 
   >>> f()
   10
   >>> k=15
   >>> f()
   10
   >>> 


Une précaution particulière s'impose quand les valeurs par défaut sont des objets modifiables. 

.. Dans le (contre)exemple suivant, le comportement de la fonction  fake_extend() est loin de celui qu'un non averti aurait pu espérer.

.. slide_mark_e
.. slide_mark_b :Les paramètres simples {tcnt_}


**Exemple** de **piège** :

.. La fonction *fake_extend()* est censée ajouter les éléments de la liste *l1* à la fin de la liste *l2*, le résultat retourné étant la liste *l2* étendue. 

.. On aurait pu espérer, à tort, qu'en cas d'appel avec un seul argument, la liste retournée contiendra les mêmes éléments que la liste fournie en argument.

.. En effet, en absence du deuxième argument à l'appel, le paramètre *l2* étant optionnel, la valeur par défaut s'applique mais le résultat n'est pas celui attendu:

Supposons que la fonction *create_user()* est destiné à la création de comptes informatiques (dans cette implémentation factice, elle retourne simplement un dictionnaire):

* Par défaut, en absence d'argument *groups* explicite, l'utilisateur créé sera associé au groupe 'lambda', le groupe de "tout le monde".
* Si l'argument is_admin est vrai, l'utilisateur sera associé en plus au groupe 'admin' qui donne des privilèges élevés. Ce groupe sera ajouté à la liste des groupes, qu'elle soit implicite ou explicite.

Avec l'implémentation suivante, les choses ne se passent pas comme prévu:

.. literalinclude:: includes/default_list2.py
   :lines: 3-

::

   >>> create_user('Poli','Christian',False) # utilisateur sans privilèges
   {'gn': 'Christian', 'sn': 'Poli', 'groups': ['lambda']}
   >>> create_user('Grand','Gourou',True) # création d'un utilisateur admin
   {'gn': 'Gourou', 'sn': 'Grand', 'groups': ['lambda', 'admin']}
   >>> create_user('Lagaffe','Gaston',False) # oups! lambda avec privileges admin!
   {'gn': 'Gaston', 'sn': 'Lagaffe', 'groups': ['lambda', 'admin']}



**Explication:**

* le premier appel se passe comme prévu, un utilisateur sans privilèges est créé
* le deuxième appel produit également le résultat attendu (l'utilisateur créé, administrateur, a les bons groupes) mais la liste *groups* (valeur par défaut dans la signature) est altérée.
* le troisième appel donne un résultat erroné (alors que les arguments sont corrects) et potentiellement dangereux: un utilisateur 'lambda' se retrouve avec des privilèges 'admin'


.. Le résultat du premier appel semble correct : en absence de *l2*, la liste retournée contient bien les même éléments que *l1*. 

.. Seulement, lors de ce premier appel, la liste *l2* a été modifiée et elle faussera le résultat du prochain appel et des suivants car elle ne sera pas remise à *[]* entre temps. 

.. Ainsi, le résultat du deuxième appel et des suivants sera erroné.

.. slide_mark_e

Arguments positionnels et arguments nommés (*keyword args*)
-----------------------------------------------------------

.. slide_mark_b :Arguments 
.. slide_insertion: **Arguments positionnels** (*non-keyword args*) **et arguments nommés** (*keyword args*)

Dans les exemples précédents les arguments à l'appel sont associés à leur paramètres correspondants par leur position à l'appel. On va parler dans ce cas d'arguments **positionnels** (*non-keyword args* en jargon pythonique). Une autre possibilité est d'exprimer les arguments sous la forme *nom=valeur* (*keyword args*) où *nom* est le nom du paramètre dans la signature. Pour ce deuxième type d'appel, l'ordre des arguments est arbitraire.

.. slide_mark_e
.. slide_mark_b :Arguments {tcnt_}

Un peut utiliser librement arguments positionnels et arguments nommés au sein d'un même appel, à condition de **ne jamais faire succéder un argument positionnel à un argument nommé** :

::

   >>> div(12,5,trunc=True)
   2
   >>> div(12,trunc=True,b=5)
   2
   >>> div(trunc=True,b=5,a=12)
   2
   >>> div(b=5,a=12,True)
   File "<stdin>", line 1
   SyntaxError: non-keyword arg after keyword arg
   >>> 

.. slide_mark_e

Le paramètre variadique à valeurs positionnelles (paramètre "étoile")
=====================================================================

.. slide_mark_b :Les paramètres variadiques

.. slide_insertion:**Le paramètre "étoile"**

Ce paramètre, quand il est présent, succède, le cas échéant, au dernier paramètre simple dans la signature et son nom est précédé par une étoile ("**\***").

.. Pour la concision, on va l'appeler parfois, dans la suite, **"paramètre étoile"**.

**NB :** Dans une signature de fonction il existe (au plus) un seul paramètre "étoile".

Il permet d'inclure dans un appel, à la suite des arguments positionnels correspondants aux paramètres simples, un nombre arbitraire d'arguments (toujours positionnels) qui seront accessibles, dans le bon ordre, en tant que membres d'un tuple désigné par la variable dont le nom est précédée par "\*":

.. slide_mark_e
.. slide_mark_b :Les paramètres variadiques {tcnt_}
.. slide_insertion:**Le paramètre "étoile"**

.. literalinclude:: includes/args.py

::

   >>> f(1,2)
   a:1
   b:2
   c:0
   args:()
   >>> f(1,2,4)
   a:1
   b:2
   c:4
   args:()
   >>> f(1,2,4,10,11,12)
   a:1
   b:2
   c:4
   args:(10, 11, 12)
   >>> f(b=1,a=2,4,10,11)
   File "<stdin>", line 1
   SyntaxError: non-keyword arg after keyword arg
   >>> 

.. slide_mark_e
.. slide_mark_b :Les paramètres variadiques {tcnt_}
.. slide_insertion:**Le paramètre "étoile"**

.. note:: Pour pouvoir passer des arguments au paramètre "étoile" il faut:

	  * Utiliser uniquement des arguments positionnels pour renseigner les paramètres simples qui le précèdent.
	  * Fournir des valeurs explicites pour **tous** ces paramètres simples, qu'ils soient obligatoires ou facultatifs.

**NB:** Ce paramètre est similaire au paramètre dit "elliptique" (\...) présent dans la signature de la fonction **printf** et des autres fonctions dites "variadiques", présentes dans certaines bibliothèques du langage **C**, du **R** etc.

.. slide_mark_e

Le paramètre variadique à valeurs nommées (double étoile)
=========================================================

.. slide_mark_b :Les paramètres variadiques {tcnt_}
.. slide_insertion:**Le paramètre double étoile**

Ce paramètre optionnel et quand il est présent, il est toujours le dernier paramètre de la signature et son nom est précédé par deux étoiles ("**\*\***").

.. On va l'appeler parfois dans la suite **"paramètre double étoile"**

**NB :** Dans une signature de fonction il existe (au plus) un seul paramètre "double étoile".

Il permet d'inclure dans un appel un nombre arbitraire d'arguments "nom=valeur" (keyword args). 

Les noms des variables correspondant aux paramètres simples qui le précèdent dans la signature ne peuvent pas servir de clé pour ses arguments pour des raisons évidentes.


.. slide_mark_e
.. slide_mark_b :Les paramètres variadiques {tcnt_}
.. slide_insertion:**Le paramètre double étoile**

.. literalinclude:: includes/kwargs.py

::

   >>> f(1,2,3,[],4,5,x=11,y=12)
   a:1
   b:2
   c:3
   args:([], 4, 5)
   kwargs:{'y': 12, 'x': 11}
   >>> f(x=55,b=6,y=2,a=2)
   a:2
   b:6
   c:0
   args:()
   kwargs:{'y': 2, 'x': 55}
   >>> 

Dans le dernier exemple on voit que les arguments "nom=valeur" correspondant au paramètres simples se mélangent sans restriction avec les arguments "nom=valeur" du paramètre ``kwargs``. 


**NB:** La fonction dict(\*\*kwargs), déjà utilisée précédemment pour définir des dictionnaires, est un exemple d'utilisation de ce paramètre.

.. slide_mark_e


Arguments exclusivement nommés (keyword-only args, Python3.x seulement)
=======================================================================

.. slide_mark_b :Arguments "keyword-only" (Python3.x seulement)

Dans certains cas, on peut souhaiter que certains arguments soient toujours nommées pour que les appels de fonctions restent lisibles (par exemple, quand le nombre d'argument est élevé ce qui rend difficile leur identification par la position)

En **Python 2.x** cela se fait via le paramètre double-étoile mais cela nécessite du code supplémentaire pour récupérer les arguments un par un à partir du dictionnaire (*kwargs* dans l'exemple précédent) ce qui est un peu fastidieux et nuit à la lisibilité mais a le "mérite" de fonctionner dans Python 2.x et 3.x.

En **Python 3.x** (seulement) on peut définir des paramètres simples à la suite du paramètre "étoile" `PEP 3102 <https://www.python.org/dev/peps/pep-3102/>`_. Ces paramètres accepteront exclusivement des arguments nommés (keyword args) lors des appels et ils peuvent être obligatoires ou facultatifs (avec valeur par défaut).


.. slide_mark_e
.. slide_mark_b :Arguments "keyword-only" {tcnt_}


.. literalinclude:: includes/kwonly.py


::

   >>> f(1,2,3,[],4,5,x=11,y=12)
   a:1
   b:2
   c:3
   args:([], 4, 5)
   x:11
   y:12
   >>> 

.. slide_mark_e
.. slide_mark_b :Arguments "keyword-only" {tcnt_}

   
Que faire si on souhaite un nombre fixe d'arguments positionnels (i.e. pas de **\*args**) ? On utilise une étoile simple :

.. literalinclude:: includes/kwonly2.py

::

   >>> f(1,2,3,[],4,5,x=11,y=12)
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   TypeError: f() takes from 2 to 3 positional arguments but 6 positional arguments (and 2 keyword-only arguments) were given
   >>> f(1,2,x=11,y=12)
   a:1
   b:2
   c:0
   x:11
   y:12
   >>> 
                    
.. slide_mark_e

Les \*var et \*\*var dans les appels de fonctions
=====================================================

.. slide_mark_b :Les \* et \*\* dans les appels de fonctions

Les préfixes \* et \** sont utilisés aussi dans les appels de fonctions:

* Avec \*iter_var on peut passer les éléments contenus dans un itérable quelconque sous forme d'arguments individuels à une fonction appelée
* Avec \*\*dict_var on peut faire la même chose avec un dictionnaire (les arguments seront de la forme nom=valeur)

**NB:** par *iter_var* on désigne ici toute variable référençant un itérable et par *dict_var* toute autre référençant un dictionnaire

.. literalinclude:: includes/varargs.py

Sans surprise, l'appel suivant de *f_call()* va échouer:

::

   >>> f_call()
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   File "<stdin>", line 3, in f_call
   TypeError: f() takes exactly 4 arguments (1 given)

En revanche, l'appel de *f_call2()* fonctionnera correctement:

::

   >>> f_call2()
   f(0,1,2,3)
   >>> 

Les expressions \*nom \*\*nom (appelées "varargs" en jargon Python) sont utiles pour construire des appels de fonctions dynamiquement, par programme.

.. slide_mark_e

Exercice
--------

.. slide_mark_b :Exercice

.. container:: myexercice

   .. literalinclude:: exercices/stats.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/stats_sol.py
      :lines: 2,10-

.. slide_mark_e

Exercice (suite)
----------------
   
.. slide_mark_b :Exercice (suite)

.. container:: myexercice

   .. literalinclude:: exercices/stats2.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/stats_sol2.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/stats_sol2b.py
      :lines: 2,10-

.. slide_mark_e

Exercice (suite)
----------------

.. slide_mark_b :Exercice (suite)

.. container:: myexercice

   .. literalinclude:: exercices/stats3.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/stats_sol3.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/stats_sol3b.py
      :lines: 2,10-

.. slide_mark_e

Exercice [2]
------------

.. slide_mark_b :Exercice [2]

.. container:: myexercice

   .. literalinclude:: exercices/print_table.py
      :lines: 2,10-

.. container:: tohide

   .. literalinclude:: exercices/print_table_sol.py
      :lines: 2,10-

.. slide_mark_e

******************************
La documentation des fonctions
******************************

.. slide_mark_b :La documentation des fonctions

La syntaxe des fonctions Python prévoit un élément dédié à leur documentation. Cet élément, appelée **docstring** est une chaîne de caractères placée après la signature et avant le corps de la fonction:

.. literalinclude:: includes/docstring.py


Tous le formats string sont acceptés, le plus courant étant le format multi-ligne (triple quote).

La docstring est accessible par programme à travers l'attribut *__doc__* ou à travers la fonction *help()*:

::

   >>> div.__doc__
   '\n    Cette fonction divise a par b,....\n    '
   >>> help(div)

   Help on function div in module docstring:

   div(a, b, trunc=False)
      Cette fonction divise a par b,....
   (END)

.. slide_mark_e

***************************
Fonctions anonymes (lambda)
***************************

.. slide_mark_b :Fonctions anonymes (lambda)

En dehors des fonctions créées avec l'instruction **def** qui ont toujours un nom et une implémentation définie par un bloc d'instructions, il existe également la possibilité de définir à la volée, pour des traitements très simples, des fonctions implémentées par une simple expression. Elles ont la forme : 


**lambda** arg_1, arg_2,...arg_n **:** expression

**Illustration :**

::

   >>> moyenne = lambda a,b: (a+b)/2.0
   >>> type(moyenne)
   <type 'function'>
   >>> moyenne(5,6)
   5.5
   >>> (lambda a,b: (a+b)/2.0)(5,6) # même chose avec évaluation directe
   5.5
   >>> 
   >>> module = lambda x: x if x>0 else -x
   >>> module(-5)
   5
   >>> module(7)
   7
   >>> (lambda x: x if x>0 else -x)(-5) # même chose avec évaluation directe
   5
   >>> (lambda x: x if x>0 else -x)(7)
   7
   >>> 

.. slide_mark_e
.. slide_mark_b :Fonctions anonymes (lambda) {tcnt_}

.. admonition:: Important
   :class: note

    L'écriture ``moyenne = lambda a,b: (a+b)/2.0`` a été utilisée dans l'illustration précédente seulement pour montrer que *moyenne* est bien une fonction.
    
    Dans le développement, les écritures de la forme ``foo = lambda x,y:...`` sont bannies par la **PEP8** et sans intérêt pratique. Si on a besoin  d'une "fonction-expression", non-anonyme, l'écriture préconisée (pour l'illustration précédente) est ``def moyenne(a, b):  return (a+b)/2.0``.

.. Couramment on utilise des expressions *lambda* pour écrire des "callbacks" (fonctions passées en argument à d'autres fonctions) avec des expressions très simples, par exemple dans une opération de tri:

.. comment!   ::

..   >>> l=[
..   ...     {'gn':'George','sn':'Washington'},
..   ...     {'gn':'John','sn':'Adams'},
..   ...     {'gn':'Thomas','sn':'Jefferson'}
..   ...     ]
..   >>> sorted(l) # pas de critère pertinent de tri...
..   [{'gn': 'George', 'sn': 'Washington'}, {'gn': 'John', 'sn': 'Adams'}, {'gn': 'Thomas', 'sn': 'Jefferson'}]
..   >>> sorted(l, key=lambda elt: elt['sn']) # tri par le nom
..   [{'gn': 'John', 'sn': 'Adams'}, {'gn': 'Thomas', 'sn': 'Jefferson'}, {'gn': 'George', 'sn': 'Washington'}]
..   >>> 

.. slide_mark_e
.. slide_mark_b :Fonctions anonymes (lambda) {tcnt_}

Différences entre les structures **lambda** et **def**:

* **lambda** est une expression alors que **def** est une instruction
* **lambda** renvoie un objet-fonction alors que **def** affecte l'objet-fonction à un nom
* **def** définit une fonction par un bloc d'instructions, **lambda** par une simple expression (pas d'instruction dans une fonction lambda, donc pas de *return* explicite)

.. admonition:: Quand utiliser des fonctions anonymes
   :class: warning

   Quand cela améliore la lisibilité du code. En règle générale, une fonction classique "trop simple" est préférable à fonction anonyme trop complexe :)

.. slide_mark_e

**********************
Conventions de nommage
**********************

.. slide_mark_b :Conventions de nommage

La **PEP8** préconise l'utilisation des noms en minuscules pour les fonctions, si nécessaire avec des underscores pour une meilleure lisibilité. L'écriture "mixedMode" est tolérée dans les contextes ou elle est déjà présente, pour assurer la compatibilité.

.. slide_mark_e

***************
Le tri revisité
***************

.. slide_mark_b :Le tri revisité


Rappel
======

* Tout itérable peut être trié
* les **séquences modifiables** (*list*, *bytearray*) disposent d'une méthode **sort()** qui trie la sequence en la modifiant et retourne **None**
* **tous les itérables** peuvent être triées avec la fonction **sorted()** qui ne modifie pas l'objet à trier et qui retourne un nouvel objet qui est le résultat du tri.

::

   >>> L = [5,2,1,8,0]
   >>> L.sort()
   >>> L
   [0, 1, 2, 5, 8]
   >>> set_ = {5,2,1,8,0} # ceci n'est pas une séquence...
   >>> sorted(set_)
   [0, 1, 2, 5, 8]
   >>> 

.. slide_mark_e
.. slide_mark_b :Le tri revisité {tcnt_}
   
Le tri en Python 2.x
====================

::

   # Signatures:
   
   sorted(iterable[, cmp[, key[, reverse]]])

   sequence.sort([cmp[, key[, reverse]]])

* *cmp:* fonction de comparaison "à l'ancienne", à 2 paramètres (disons x et y) qui retourne:

  * une valeur négative si x<y
  * zéro si x==y
  * une valeur positive si x>y
* *key:* fonction à un seul paramètre qui retourne la clé à comparer pour chaque item
* *reverse:* booléen

.. slide_mark_e
.. slide_mark_b :Le tri revisité {tcnt_}

  
Illustration:
=============

.. literalinclude:: includes/sort_pers.py


::

   >>> # tri avec cmp=cmp_sn
   >>> sorted(us_presidents,cmp=cmp_sn)
   [{'gn': 'John', 'sn': 'Adams'}, {'gn': 'Thomas', 'sn': 'Jefferson'}, {'gn': 'George', 'sn': 'Washington'}]
   >>> # même chose avec une fonction lambda (assez illisible...)
   >>> sorted(us_presidents,cmp=lambda p1, p2: 1 if p1['sn'] > p2['sn'] else -1 if  p1['sn'] < p2['sn'] else 0)
   [{'gn': 'John', 'sn': 'Adams'}, {'gn': 'Thomas', 'sn': 'Jefferson'}, {'gn': 'George', 'sn': 'Washington'}]
   >>> # key + lambda (bien adaptée car très simple)
   >>> sorted(us_presidents,key=lambda p: p['sn'])
   [{'gn': 'John', 'sn': 'Adams'}, {'gn': 'Thomas', 'sn': 'Jefferson'}, {'gn': 'George', 'sn': 'Washington'}]
   >>> # même chose avec reverse
   >>> sorted(us_presidents,key=lambda p: p['sn'], reverse=True)
   [{'gn': 'George', 'sn': 'Washington'}, {'gn': 'Thomas', 'sn': 'Jefferson'}, {'gn': 'John', 'sn': 'Adams'}]
   >>> 

.. slide_mark_e
.. slide_mark_b: Le tri revisité {tcnt_}

   
Le tri en Python 3.x
====================

::

   # Signatures:
   
   sorted(iterable[, key][, reverse])

   sequence.sorted([key][, reverse])

Ce qui change:
--------------

* les fonctions **cmp** ne sont plus supportées. La bibliothèque standard fournit la fonction **functools.cmp_to_key()** qui est un outil de transition entre les versions.
* les paramètres facultatifs (key, reverse) exigent des arguments keyword à l'appel
  
::

   >>> import functools
   >>> sorted(us_presidents, key=functools.cmp_to_key(cmp_sn))
   [{'gn': 'John', 'sn': 'Adams'}, {'gn': 'Thomas', 'sn': 'Jefferson'}, {'gn': 'George', 'sn': 'Washington'}]
   >>> 

Pour en savoir plus: https://docs.python.org/3/howto/sorting.html#the-old-way-using-the-cmp-parameter

.. slide_mark_e

.. sorted(us_presidents,cmp=lambda p1, p2: 1 if p1['sn'] > p2['sn'] else -1 if  p1['sn'] < p2['sn'] else 0)

.. sorted(us_presidents,key=lambda p: p['sn'])

.. sorted(us_presidents,key=lambda p: p['sn'], reverse=True)
