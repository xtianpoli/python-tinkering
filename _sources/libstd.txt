################################
La bibliothèque standard en bref
################################

.. slide_mark_b :La bibliothèque standard en bref

Il s'agit d'un simple aperçu, partiel et partial, de quelques fonctions avec les paramètres les plus courants dans le but de donner un avant goût des possibilités de cette bibliothèque, très riche. Il est donc fortement conseillé de consulter constamment la documentation de référence pour une utilisation correcte de la bibliothèque standard dans le processus de développement.

.. slide_mark_e

**********************************************
Les outils pour la programmation fonctionnelle
**********************************************


Généralités
===========

La programmation fonctionnelle (P.F) est née du souhait de dépasser les limitations de la programmation impérative qui la rendent inadéquate à la manipulation des objets mathématiques.

En effet, la (ré)affectation de variable, propre à la programmation impérative n'est pas compatible avec les exigences de la démarche mathématique pour laquelle les objets "mutables" n'ont aucun sens. Les variables, dans la programmation impérative, sont plus proches, conceptuellement, des cellules mémoire de l'architecture de Von Neumann que des variables mathématiques.

Pour surmonter cet inconvénient, un paradigme différent s'impose. Un programme cesse d'être une suite d'instructions à exécuter pour devenir une expression à évaluer.

Le fonctions occupent le rôle clé dans cette nouvelle approche (et inspirent son nom!).

Sans effets de bord, elles ressemblent aux fonctions mathématiques. Elles sont des objets de "première classe". Des fonctions d'ordre supérieur ainsi que les appels récursif remplacent les structures de boucle.

Ca va de soi, dans une telle approche, les changements d'état, les modifications de données sont bannis.

.. slide_mark_b :Les outils pour la programmation fonctionnelle

Les avantages revendiquées par ce paradigme (considéré au sens "strict", P.F. "pure") sont, principalement:

* Prouvabilité formelle des programmes
* Décomposabilité/Composabilité des programmes
* Testing et mise au point facilités

.. slide_mark_e
.. slide_mark_b :Les outils pour la programmation fonctionnelle {tcnt_}   
  
Dans la pratique, on rencontre deux manières d'aborder la programmation fonctionnelle :

* Dans un sens strict, correspondant aux langages fonctionnels "purs", dénués de variables et d'objets mutables ainsi que de structures de contrôle impératifs (sous-ensembles purement fonctionnels de OCaml, Haskell, Pure Lisp etc.)
* Dans un sens plus libre, propre à certains langages multi-paradigme qui, sans bannir les idiomes des la programmation impérative, offrent les moyens d'écrire des programmes élégants avec des moyens apportés par paradigme fonctionnel (emploi des fonctions d'ordre supérieur pour remplacer des structures de contrôle impératifs etc.). Python s'inscrit dans ce deuxième courant.
  
.. slide_mark_e  
.. slide_mark_b :Les outils pour la P.F. {tcnt_}

   
En effet, Python contient des éléments de langage propres à la programmation fonctionnelle :

* les fonctions sont des objets de première classe
* il permet la définition de fonctions d'ordre supérieur (fonctions qui manipulent d'autres fonctions)
* il offre des mécanismes avancés pour le traitement des listes et des itérables en général:

  * listes en intension et générateurs-expression
  * des nombreuses fonctions d'ordre supérieur prédéfinies (module **functools**)
  * une large palette de fonctions sur les itérateurs (module **itertools**)    
  * d'autres primitives sur les itérables: *all()*, *any()*, *min()*, *max()*   

.. slide_mark_e  
.. slide_mark_b :Les outils de la P.F. {tcnt_}
   
Bien sûr, Python n'est pas un langage fonctionnel "pur" car :

* il n'encourage pas l'utilisation de la récursivité à la place des structures de boucle *for* et *while*
* par défaut, il n'empêche pas les effets de bord ni les données modifiables.

  
..  http://www.artima.com/weblogs/viewpost.jsp?thread=98196

.. slide_mark_e

Les fonctions d'ordre supérieur
===============================



En anglais "Higher-order functions" = HOF   

Nous avons vu qu'en Python, les fonctions sont des objets de "première classe" i. e.  un objet fonction peut être affecté à une variable, passé en paramètre à une fonction ou retourné par une fonction.

Les fonctions qui manipulent et/ou qui créent des objets fonctions sont appelées "fonctions d'ordre supérieur"=FOS, en anglais :  "Higher-order functions" = HOF.

Entre autres, **les décorateurs en font partie**.

Les trois fonctions suivantes, *map*, *filter* et *reduce*   sont "piliers" de la programmation fonctionnelle dans le sens où elles sont présentes  dans quasiment  tous les langages qui s'en revendiquent.

Elles sont présentes également dans Python mais, dans la pratique, *map* et *filter* perdent du terrain en faveur des listes en intension et des générateurs-expression


.. slide_mark_b :Les fonctions d'ordre supérieur

* **map(f, iterable1, iterable2,...)** : applique la fonction *f* sur chaque item résultat d'une itération:

  * le nombre d'arguments de la fonction doit correspondre avec le nombre d'itérables à traiter
  * les itérables seront traités parallèlement : la fonction recevra en argument, lors d'une itération *i*, le i-ème élément de chaque
  * le processus s'arrête lorsque la fin de l'itérable le plus court est atteinte

* **filter(f, iterable_in)** : applique la fonction *f* à tous les éléments de *iterable_in* et renvoie un nouvel itérable construit à partir des éléments du premier pour lesquels *f* renvoie *True*
* **reduce(f, iterable_in[,init])** : applique la fonction *f* (à deux arguments) à tous les items de *iterable_in* de manière cumulative, de gauche à droite:

  * pour [1,2,3,4] le résultat sera équivalent à  ``f(f(f(1,2),3),4)`` 
  * Si init est fourni, il sera utilisé dans le processus comme l'élément le plus à gauche. pour init=99 l'équivalent en terme de résultat sera ``f(f(f(f(99,1),2),3),4)``
  * **NB:** En version 3, la fonction *reduce* a été déplacée dans le module *functools* (cf. http://docs.python.org/3.0/whatsnew/3.0.html)

Le même document `WHATSNEW <http://docs.python.org/3.0/whatsnew/3.0.html>`_ préconise l'utilisation des listes en intension à la place de *map* et *filter* quand le résultat souhaité est une liste (car en version 3 ces deux fonctions fournissent des itérateurs en sortie)

**NB :** Les fonctions *map()* et *filter()* renvoient une liste en version 2 et un itérateur en version 3.

.. slide_mark_e


Avant d'entrer dans les détails...
----------------------------------

.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}
.. slide_insertion:Avant d'entrer dans les détails...

On va mentionner l'existence du module **operator** qui peut être décrit en quelques mots: il rend accessible tous les opérateurs sous forme de fonction : ( "add" pour "+", "sub" pour "-", "mul" pour "*" etc.)



.. slide_mark_e

La fonction *map*
-----------------

.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}
.. slide_insertion:La fonction *map*


Illustrée via un exemple simple et mise en perspective avec une écriture équivalente avec des itérables en intension :   
   
.. literalinclude:: includes/simple_map2.py

.. slide_mark_e
.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}

                    
::

   >>> res = map(full_name,lst); list(res)
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>> # même traitement avec des listes en intension et générateurs-expression:
   >>> [full_name(e) for e in lst]
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>> res = (full_name(e) for e in lst); list(res)
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>>
   
.. slide_mark_e
.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}

Les fonctions anonymes sont souvent employées pour définir des transformations à appliquer sur tous les items d'un itérable, via une fonction d'ordre supérieur comme *map()* :

::

   >>> res = map(lambda x: "{0[gn]} {0[sn]}".format(x), lst); list(res)
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>> # même traitement avec des listes en intension (pas besoin de lambda):
   >>> ["{0[gn]} {0[sn]}".format(e) for e in lst]
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>> # générateur-expression
   >>> res = ("{0[gn]} {0[sn]}".format(x) for e in lst); list(res)
   ['George Washington', 'John Adams', 'Thomas Jefferson']
   >>>

**Important :** Nous remarquerons dans l'exemple précédent que la fonction anonyme devient inutile dans l'écriture "en intension" !
   
.. slide_mark_e
.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}
   
   
**Remarque:** *map()* permet de travailler en parallèle sur plusieurs itérables. Pour faire la même chose avec les itérables en intension on va utiliser la fonction **zip()**:


.. literalinclude:: includes/double_map.py


.. slide_mark_e
.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}

                    
::

   >>> res = map(prod, lst1, lst2); list(res)
   [7, 16, 27, 40, 55]
   >>> # grace au module "operator" on évite d'écrire des fonctions superflues (comme "prod") :
   >>> import operator
   >>> res = map(operator.mul, lst1, lst2); list(res)
   [7, 16, 27, 40, 55]
   >>> # avec des listes en intension:
   >>> [prod(x,y) for (x,y) in  zip(lst1, lst2)]
   [7, 16, 27, 40, 55]
   >>> # ou encore:
   >>> [x*y for (x,y) in  zip(lst1, lst2)]
   [7, 16, 27, 40, 55]
   >>> # générateur-expression
   >>> res = (prod(x,y) for (x,y) in  zip(lst1, lst2)); list(res)
   [7, 16, 27, 40, 55]

   
.. slide_mark_e

La fonction *filter*
====================

.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}
.. slide_insertion:La fonction *filter*

::

   >>> lst = list(range(-5,8)); lst
   [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7]
   >>> res = filter(lambda x: x>0, lst); list(res)
   [1, 2, 3, 4, 5, 6, 7]
   >>> # avec des listes en intension:
   >>> [x for x in lst if x>0]
   [1, 2, 3, 4, 5, 6, 7]
   >>>
   
.. slide_mark_e

La fonction *reduce*
====================

.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}
.. slide_insertion:La fonction *reduce*

**Rappel :** cette fonction à été déplacée dans le module **functools** dans **Python 3.x**
   
::
   >>> from functools import reduce # en Python 3.x
   >>> list(range(1,5))
   [1, 2, 3, 4]
   >>> def sum(x,y):
   ...     return x+y
   ... 
   >>> reduce(sum, range(1,5))
   10
   >>> # factorielle de 5:
   >>> from functools import reduce
   >>> reduce(lambda x,y:x*y, range(1,6)) 
   120
   >>>    

.. slide_mark_e
.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}

   
La même chose, avec les fonctions du module *operator* :

::
   
   >>> import operator
   >>> reduce(operator.add, range(1, 5))
   10
   >>> reduce(operator.mul, range(1, 6))
   120
   >>> 

.. slide_mark_e   
   
Autres fonctions d'ordre supérieur
----------------------------------

Les deux fonctions suivantes font également partie du module **functools** qui en contient bien d'autres.
On les a choisi pour les présenter brièvement car elles sont un peu "emblématiques" pour la programmation fonctionnelle.

L'application partielle d'une fonction
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}
.. slide_insertion: L'application partielle d'une fonction    


**Exemple :** dans la fonction suivante, de variable **x** et paramètre **k** :

.. math::

   f_{k}(x) = kx^2 + (2k + 1)x + 5 

on souhaite fixer le paramètre **k** à **3** pour obtenir :

.. math::
   
   f_{3}(x) = 3x^2 + 7x + 5 

::

   >>> import functools
   >>> 
   >>> def fk(k, x):
   ...     return k * x**2 + (2*k +1)*x + 5 
   ... 
   >>> f3 = functools.partial(fk, 3)
   >>> f3(5)
   115
   >>> 

.. slide_mark_e      
   
Fonctions génériques (single-dispatch generic functions)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}
.. slide_insertion: Fonctions génériques (single-dispatch generic functions)

.. literalinclude:: includes/generic_fun.py

.. slide_mark_e
.. slide_mark_b :Les fonctions d'ordre supérieur {tcnt_}   
                    
::

   >>> fun(list("Python"))
   i:  0  elt:  P
   i:  1  elt:  y
   i:  2  elt:  t
   i:  3  elt:  h
   i:  4  elt:  o
   i:  5  elt:  n
   >>> fun(dict(a=1, b=5, c=6))
   key:  b  value:  5
   key:  a  value:  1
   key:  c  value:  6
   >>> fun("abc")
   What is this?  abc
   >>>
   
.. slide_mark_e

Le module *itertools*
=====================

.. slide_mark_b :Le module *itertools*


`itertools <https://docs.python.org/3/library/itertools.html>`_ fournit des itérables très utiles, en programmation fonctionnelle ou impérative.


Ils sont nombreux, l'utilisation de deux d'entre eux est illustrée ici sur un exemple. Soit le générateur suivant implémentant une série:

.. literalinclude:: includes/exo_itertools.py

.. slide_mark_e
.. slide_mark_b :Le module *itertools* {tcnt_}   
                    
On souhaite implémenter un itérable "paresseux" qui fournit à chaque itération, le terme courant de la série et la somme des éléments déjà générés. On va utiliser:

* **itertools.tee** qui produit **n** itérateurs indépendants à partir d'un itérable unique
* **itertools.accumulate** renvoie les résultats partiels de l'opération fournie en 2ème position (par défaut, la somme) appliquée aux éléments de l'itérateur en entrée

.. slide_mark_e
.. slide_mark_b :Le module *itertools* {tcnt_}   
  
::

   >>> from itertools import accumulate, tee
   >>> crt, acc = tee(series(), n=2)
   >>> crt_acc = zip(crt, accumulate(acc))
   >>> for res, _ in zip(crt_acc, range(5)):
   ...     print(res)
   ... 
   (-5, -5)
   (4, -1)
   (15, 14)
   (28, 42)
   (43, 85)
   >>> 


.. slide_mark_e

   
****************************
La manipulation des fichiers
****************************

.. slide_mark_b :La manipulation des fichiers

Le type **file** est un des types prédéfinis en Python, déjà évoqué précédemment pour illustrer la structure **with**. Pour ouvrir un fichier, on utilise le plus souvent la fonction prédéfinie *open()*  à la place du constructeur *file()*. Il y a des différences notables entre les versions 2 et 3 au niveau de la signature de *open()*.

En Python 2.7.x:

::

   open(name[, mode[, buffering]])


* name : nom du fichier (absolut ou relatif au répertoire courant)
* mode :

  * **r** : lecture (par défaut)
  * **w** : écriture (en début du fichier). **Avertissement:** Si le fichier existe le contenu courant sera perdu.
  * **a** : ajout (append) L'écriture se fera à la fin du fichier, s'il existe, sinon il sera créé.
  * **r+**, **w+**, **a+** : ouverture en mise à jour(lecture/écriture). **Avertissement:** tout comme le *w*, le *w+* tronque le fichier, le contenu existant sera perdu.
  * **b** : il s'additionne à un des flags précédents (ex: *rb*) et il signifie *binary* pour les systèmes qui en font la distinction par rapport au mode text.

* buffering : gestion de la zone mémoire "tampon":

  * 0 : pas de mémoire tampon
  * 1 : mode "ligne"
  * > 1 : taille du tampon (en octets)
  * < 0 : taille par défaut prévue par le système (et comportement par défaut de la fonction)

.. slide_mark_e
.. slide_mark_b :La manipulation des fichiers {tcnt_}

En Python 3.x:

::

    open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)

* file : peut être un chemin (comme précédemment) ou un descripteur de fichier. Si *file* est un descripteur, le fichier correspondant sera fermé par *close()*, sauf si *closefd=False*
* mode :

  * **r**, **w**, **a**, **+** : avec les significations décrites précédemment 
  * **x** création uniquement, erreur si le fichier existe déjà.  *(nouveauté Python 3.3)*
  * **b** : signification nouvelle car il implique que le résultat rendu sera de type **bytes** alors que par défaut (mode "texte") le résultat est de type **str** ce qui signifie **unicode** en Python 3.x. En mode "texte", l'encodage sera:

    * celui prévu par *encoding* s'il est défini
    * celui fourni par ``locale.getpreferredencoding(False)`` dans le cas contraire
  * **t** mode "texte" (par défaut)
* encoding : encodage
* errors : peut contenir une des chaînes:

  * 'strict' provoque une *ValueError* en cas de caractère non supportée (valeur par défaut)
  * 'ignore' ignore les erreurs d'encodage avec le risque de perte de données
  * 'replace' remplace les caractères en erreur par un marqueur ('?')
  * 'surrogateescape' représente les octets non reconnus par un point code dans la plage U+DC80 - U+DCFF
  * 'xmlcharrefreplace' remplace les caractères non supportés  par l'encodage avec l'entité XML *&#nn;* (en écriture seulement)
  * 'backslashreplace'  remplace les caractères non supportés  par l'encodage avec les séquence d'échapement \nnn

* newline : valeurs possibles None, '', '\\n', '\\r', et '\\r\\n'
* closefd : déjà évoqué pour "file". Si "file" est un nom il est sans effet et il doit contenir la valeur par défaut.
* opener : fonction utilisateur destiné à l'ouverture du fichier *(nouveauté Python 3.3)*

.. slide_mark_e
.. slide_mark_b :La manipulation des fichiers {tcnt_}

**Rappel:**


::

   >>> with open("/tmp/fich.txt","w") as fd:
   ...     fd.write("some text")

Est l'équivalent de:

::

   >>> fd = open("/tmp/fich.txt","w")
   >>> try:
   ...     fd.write("some text")
   ... finally:
   ...     fd.close()

.. slide_mark_e

Les autres méthodes sur les fichiers
====================================

.. slide_mark_b :Les autres méthodes sur les fichiers

* read(size) : *size* exprime la quantité de données à lire : s'il est négatif ou absent tout le fichier sera lu
* seek(offset,from_what) positionnement dans le fichier. *from_what* représente l'origine par rapport à laquelle l'offset est exprimé et peut prendre trois valeurs:

  * 0 : début du fichier
  * 1 : la position courante dans le fichier
  * 2 : fin du fichier
* tell() fournit la position courante dans le fichier

Exemple:

::

   >>> f=open("/tmp/testfile.txt","r+")
   >>> f.read()
   '01234567890123456789\n'
   >>> f.seek(3)
   >>> f.read()
   '34567890123456789\n'
   >>> f.seek(-3,2)
   >>> f.read()
   '89\n'
   >>> f.tell()
   21
   >>> f.read()
   ''
   >>> f.seek(-3,2)
   >>> f.write("xy")
   >>> f.seek(5)
   >>> f.write("ab")
   >>> f.seek(0)
   >>> f.read()
   '01234ab78901234567xy\n'
   >>> 

.. slide_mark_e

*****************
Le module **sys**
*****************

.. slide_mark_b :Le module **sys**

C'est le module, déjà évoqué dans les chapitres précédents, joue principalement deux rôles:

* il fournit au programme les moyens de base d'interagir avec son environnement d'exécution (entrées/sorties, arguments de la ligne de commande)
* il donne au programme l'accès aux paramètres de l'interpréteur 

Le script suivant affiche les arguments de la ligne de commande:

.. literalinclude:: includes/print_argv.py

::

   $ ./print_argv.py 66 abc
   0: ./print_argv.py
   1: 66
   2: abc

.. slide_mark_e
.. slide_mark_b :Le module **sys** {tcnt_}

Quelques autres attributs et fonctions de ce module, illustrés par des exemples:

::

   >>> import sys
   >>> sys.executable
   '/usr/bin/python'
   >>> sys.platform
   'linux2'
   >>> sys.version
   '2.7.3 (default, Sep 26 2013, 20:03:06) \n[GCC 4.6.3]'
   >>> sys.getdefaultencoding()
   'ascii'
   >>> sys.modules # les modules chargés par l'interpréteur
   {'copy_reg': <module 'copy_reg' from '/usr/lib/python2.7/copy_reg.pyc'>, ....}
   >>> sys.path
   ['', '/usr/lib/python2.7', '/usr/lib/python2.7/plat-linux2', '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old', '/usr/lib/python2.7/lib-dynload', '/usr/local/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages']
   >>> sys.stdout.write("Un message")
   Un message>>> sys.stdout.write("Un autre message \n")
   Un autre message 
   >>> sys.stderr.write("Une erreur\n")
   Une erreur
   >>> sys.exit(0) # fin de l'exécution

.. slide_mark_e

******************************************
L'interface avec le système d'exploitation
******************************************

.. slide_mark_b :L'interface avec le système d'exploitation

.. _file_management:
   
Il s'agit des fonctionnalités souvent équivalentes aux commandes système usuelles. Elles se retrouvent dans plusieurs modules dont **os**, **shutil** et **glob**

.. slide_mark_e



.. include:: _filestuff.RST

.. slide_mark_b :Le module **os** {tcnt_}

::

    os.walk(top, topdown=True, onerror=None, followlinks=False)

Cette fonction permet de parcourir une arborescence de fichiers ayant pour racine le répertoire *top*. Elle retourne un générateur qui fournit à chaque itération un triplet de valeurs contenant:

* le nom du répertoire courant
* la liste des sous-répertoires directs
* la liste des fichiers membres

Les options:

* topdown : 
  
  * True : l'itération se fait à partir de la racine (valeur par défaut)
  * False: l'itération se fait à partir des "feuilles"

* onerror : None (par défaut) ou une fonction utilisateur qui sera appelée en cas d'erreur.

* followlinks : suivi des liens symboliques (si *True*). Peut provoquer une récursion infinie en cas de liens cycliques

.. slide_mark_e
.. slide_mark_b :Le module **os** {tcnt_}

Exemples:

* top-down :

  ::

     >>> import os
     >>> g=os.walk("/usr/local/lib/python2.7/dist-packages/")
     >>> type(g)
     <type 'generator'>
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/', ['django_http_proxy-0.3.2-py2.7.egg', 'django_guardian-1.0.4-py2.7.egg', 'Whoosh-2.4.1-py2.7.egg', 'vnc2flv', 'codenode-0.02-py2.7.egg', 'django', 'easy_thumbnails-1.0.3-py2.7.egg', 'Twisted-12.3.0-py2.7-linux-x86_64.egg', 'django_userena-1.1.2-py2.7.egg', 'django_compress-1.0.1-py2.7.egg', 'django_passwords-0.2.0-py2.7.egg'], ['vnc2flv-20100207.egg-info', 'flvscreen.so', 'Django-1.5.4.egg-info', 'easy-install.pth'])
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/django_http_proxy-0.3.2-py2.7.egg', ['EGG-INFO', 'httpproxy'], [])
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/django_http_proxy-0.3.2-py2.7.egg/EGG-INFO', [], ['zip-safe', 'SOURCES.txt', 'PKG-INFO', 'dependency_links.txt', 'top_level.txt'])
     >>> # etc...

* bottom-up :

  ::

     >>> g=os.walk("/usr/local/lib/python2.7/dist-packages/",topdown=False)
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/django_http_proxy-0.3.2-py2.7.egg/EGG-INFO', [], ['zip-safe', 'SOURCES.txt', 'PKG-INFO', 'dependency_links.txt', 'top_level.txt'])
     >>> next(g)
     ('/usr/local/lib/python2.7/dist-packages/django_http_proxy-0.3.2-py2.7.egg/httpproxy', [], ['views.pyc', 'settings.pyc', 'recorder.py', '__init__.py', 'exceptions.pyc', 'views.py', 'settings.py', 'decorators.py', 'models.pyc', 'recorder.pyc', 'models.py', 'admin.py', '__init__.pyc', 'admin.pyc', 'decorators.pyc', 'exceptions.py'])
     >>> 


.. slide_mark_e
.. slide_mark_b :Le module **os** {tcnt_}


.. admonition:: A manipuler avec précaution
   :class: warning

	   * remove(path) supprime le fichier
	   * rmdir(path) supprime le répertoire s'il est vide

.. slide_mark_e

.. include:: _filestuff2.RST   

*******************
Les (sous)processus
*******************

.. slide_mark_b :Les (sous)processus

Les situations les plus courantes nécessitant le lancement des nouveaux processus sont traitées par quelques fonctions du module **subprocess** :

::

   subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None) # timeout existe seulement en version 3.x


C'est une signature abrégée, le deuxième paramètre ``*`` symbolise des paramètres moins utilisés qui ne seront pas discutés ici.

* args : représente la commande à exécuter. Peut être une liste ou une chaîne de caractères
* stdin, stdout, stderr : redirection possible des entrées/sorties standard
* shell : si ``shell=True`` la commande sera exécutée par le *shell*


.. admonition:: Avertissement
   :class: warning

   L'argument shell=True représente un risque important en terme de sécurité en particulier en présence d'entrées non fiables. Son utilisation est *vivement déconseillée*.


Cette fonction:

* exécute la commande exprimée par args
* attend la fin de l'exécution
* renvoie le code de retour système

.. slide_mark_e
.. slide_mark_b :Les (sous)processus {tcnt_}

::

   >>> subprocess.call("ls")
   controller  __init__.py  __init__.pyc  model  view
   0
   >>> subprocess.call(["ls", "view"])
   admviews.py   appviews1.py   appviews1.pyc  appviews2.pyc  __init__.pyc
   admviews.pyc  appviews1.py~  appviews2.py   __init__.py
   0
   >>> subprocess.call(["ls","-l", "/tmp/locked.txt"])
   ---------- 1 poli poli 0 mars  11 15:44 /tmp/locked.txt
   0
   >>> subprocess.call(["cat", "/tmp/locked.txt"])
   cat: /tmp/locked.txt: Permission non accordée
   1
   >>> 

.. slide_mark_e
.. slide_mark_b :Les (sous)processus {tcnt_}

::

   subprocess.check_call(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None) # timeout existe seulement en version 3.x

Effectue le même traitement que *subprocess.call()* mais lève une exception si le code de retour est *!=0*

::

   >>> subprocess.check_call(["cat", "/tmp/locked.txt"])
   cat: /tmp/locked.txt: Permission non accordée
   Traceback (most recent call last):
   File "<stdin>", line 1, in <module>
   File "/usr/lib/python2.7/subprocess.py", line 511, in check_call
   raise CalledProcessError(retcode, cmd)
   subprocess.CalledProcessError: Command '['cat', '/tmp/locked.txt']' returned non-zero exit status 1
   >>> 

.. slide_mark_e
.. slide_mark_b :Les (sous)processus {tcnt_}

::

   subprocess.check_output(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None) # timeout existe seulement en version 3.x

Effectue le même traitement que ``subprocess.check_call()`` mais retourne la sortie standard:

::

   >>> result = subprocess.check_output(["echo", "Hello"])
   >>> result
   'Hello\n'
   >>>

.. note:: Des utilisation avancées de ce module, qui dépassent le cadre de cette introduction, passent par l'utilisation directe de la classe **subprocess.Popen**

.. slide_mark_e

**********************
Le module **platform**
**********************

.. slide_mark_b :Le module **platform**

Comme son nom l'indique ce module fournit des informations sur la plateforme :


* Architecture : platform.architecture(executable='/usr/bin/...')
* Type de matériel : platform.machine()
* Nom réseau de l’hôte : platform.node()
* Chaîne de caractère contenant système, release, type de machine etc. : platform.platform()
* Nom du processeur : platform.processor()
* Infos système (nom,version,release) du système : platform.system(), platform.version(), platform.release()
* Infos sur l’interpréteur : python_build(), python_compiler(), python_version()

.. slide_mark_e

**************************
L'accès à Internet en http
**************************

.. slide_mark_b :L'accès à Internet en http

Un module simple permettant de faire des requêtes *http* est *urllib.request* (*urllib2* en *Python 2.7.x*). Pour une utilisation basique il suffit de passer une *url* en argument à la fonction *urlopen()* qui retournera un itérateur qui permet de récupérer le résultat, ligne par ligne:

::

   >>> from urllib.request import urlopen # for Python 3.x
   >>> #from import urllib2 import urlopen # for Python 2.7.x
   >>> i = urlopen("http://example.org")
   >>> next(i)
   '<!doctype html>\n'
   >>> next(i)
   '<html>\n'
   >>> next(i)
   '<head>\n'
   >>> # ...

On peut également récupérer le résultat d'un coup:

::

   >>> urlopen("http://example.org").read()
   '<!doctype html>\n<html>\n<head>\n ...

.. slide_mark_e

***********************
Compression des données
***********************

.. slide_mark_b :Compression des données

Les formats courants sont supportés:


* zlib
* gzip
* bz2
* zipfile 
* tarfile

Illustration  :

::

   >>> import zlib
   >>> citation = b"Davantage d'avantages avantagent davantage." # Boby Lapointe
   >>> len(citation)
   43
   >>> zipped = zlib.compress(citation)
   >>> len(zipped)
   32
   >>> zlib.decompress(zipped)
   "Davantage d'avantages avantagent davantage."
   >>> 

.. slide_mark_e

****************************
**ConfigParser** et **json**
****************************

.. slide_mark_b :**ConfigParser**

*Configparser*, renommé *configparser* en version 3, permet de créer et parser des fichiers de configuration de type **.ini**, **.cfg** etc., assez répandus dans tous les environnements.

Création d'un fichier de configuration (pour un logiciel imaginaire):

::

   >>> import ConfigParser
   >>> conf = ConfigParser.RawConfigParser()
   >>> conf.add_section("ClientSide")
   >>> conf.set("ClientSide","buffer",1000)
   >>> conf.set("ClientSide","timeout",10)
   >>> conf.add_section("ServerSide")
   >>> conf.set("ServerSide","db","mysql")
   >>> conf.set("ServerSide","logs","/var/log/mysrv")
   >>> with open("myconf.cfg","w") as fd:
   ...     conf.write(fd)

Résultat :

::

   $ cat myconf.cfg 
   [ClientSide]
   buffer = 1000
   timeout = 10

   [ServerSide]
   db = mysql
   logs = /var/log/mysrv

.. slide_mark_e
.. slide_mark_b :**ConfigParser** {tcnt_}

Pour parser le fichier de configuration précédent:

::

   >>> conf = ConfigParser.RawConfigParser()
   >>> conf.read("myconf.cfg")
   ['myconf.cfg']
   >>> conf.getint("ClientSide","buffer")
   1000
   >>> conf.get("ServerSide","db")
   'mysql'

.. slide_mark_e
.. slide_mark_b :*JSON*

*JSON*, acronyme de *JavaScript Object Notation*, est un format d'échange très utilisé. Les structures de données *JavaScript* étant assez proches de celles de Python (listes, dictionnaires), l'utilisation de *JSON* est très intuitive;

::

   >>> import json
   >>> some_data = {'a':3, 'b':[5,'xyz']}
   >>> json.dumps(some_data)
   '{"a": 3, "b": [5, "xyz"]}'
   >>> txt = json.dumps(some_data)
   >>> type(txt)
   <type 'str'>
   >>> json.loads(txt)
   {u'a': 3, u'b': [5, u'xyz']}
   >>> data = json.loads(txt)
   >>> type(data)

.. slide_mark_e

***********************
Mesure des performances
***********************

.. slide_mark_b :Mesure des performances

Le module *timeit* offre un moyen simple pour comparer des performances entre plusieurs implémentations d'une fonctionnalités, plusieurs approches d'un même problème etc.

Par exemple, on peut comparer le temps nécessaire pour la construction d'une liste de 100 éléments avec le temps pour construire un générateur équivalent:

::

   >>> from timeit import Timer
   >>> Timer('[e**2 for e in xrange(1,100)]').timeit()
   9.104944229125977
   >>> Timer('(e**2 for e in xrange(1,100))').timeit()
   0.6118359565734863

...et le temps pour fabriquer la liste indirectement, en passant par la fabrication du dit générateur:

::

   >>> Timer('list((e**2 for e in xrange(1,100)))').timeit()
   10.48848009109497

.. slide_mark_e

*******************
Le module **math**
*******************

.. slide_mark_b :Le module **math**

Fournit des fonctions de base en théorie des nombres, logarithmes, trigonométrie, conversions d'angles etc:


::

   >>> import math
   >>> math.tan(math.pi/4)
   0.9999999999999999
   >>> math.pi
   3.141592653589793
   >>> math.e
   2.718281828459045
   >>> math.log(math.e**3) # logarithme naturel (appel à 1 seul argument)
   3.0
   >>> math.log(1000,10) # 2 args, équivalent  log(x)/log(10)
   2.9999999999999996
   >>> math.log10(1000) # log décimal, plus précis que log(x,10)
   3.0
   >>> math.radians(90) # pi/2
   1.5707963267948966
   >>> math.degrees(math.pi/2)
   90.0
   >>> # etc.
   ... 

.. slide_mark_e

********************
Le module **random**
********************

.. slide_mark_b :Le module **random**

Fournit des générateurs de nombres pseudo-aléatoires.

::

   >>> import random
   >>> random.random()
   0.28578533604922873
   >>> random.randrange(16)
   15
   >>> random.randrange(16)
   10
   >>> random.choice("abc")
   'c'
   >>> random.choice("abc")
   'a'
   >>> 

.. slide_mark_e

********************************************
Les expressions rationnelles (ou régulières)
********************************************

.. slide_mark_b :Les expressions rationnelles (ou régulières)

::

   >>> re.findall(r'\bon[a-z]*', 'There should be one-- and preferably only one --obvious way to do it.')
   ['one', 'only', 'one']
   >>> prog= re.compile(r'\bon[a-z]*') # avec un motif compilé
   >>> prog.findall('There should be one-- and preferably only one --obvious way to do it. (Tim Peters)')
   ['one', 'only', 'one']

.. slide_mark_e











